<?xml version="1.0" encoding="UTF-8"?>
<exportedData version="39" buildLabel="" buildVersion="3.5.0.0">
	<exportPath>/projects/@PLUGIN_KEY@-@PLUGIN_VERSION@</exportPath>
	<project>
		<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
		<description>Integration with Gerrit</description>
		<workspaceName/>
		<propertySheet>
			<property>
				<propertyName>procedure_helpers</propertyName>
				<description/>
				<propertySheet>
					<property>
						<propertyName>api</propertyName>
						<description/>
						<expandable>1</expandable>
						<value>use ElectricCommander;&#10;use File::Basename;&#10;use ElectricCommander::PropDB;&#10;use ElectricCommander::PropMod;&#10;use Switch;&#10;&#10;$|=1;&#10;&#10;my $ec = new ElectricCommander();&#10;$ec-&gt;abortOnError(0);&#10;&#10;my $cfgName = "$[gerrit_cfg]";&#10;my $proj = 'EC-Gerrit-1.1.1.0';&#10;my $cfg = new ElectricCommander::PropDB($ec,"/projects/$proj/gerrit_cfgs");&#10;my %vals = $cfg-&gt;getRow($cfgName);&#10;my $opts = \%vals;&#10;&#10;# get pseudo code snippets&#10;my $code = new ElectricCommander::PropDB($ec,"/projects/$proj/gerrit_code");&#10;my %code_vals = $code-&gt;getRow($cfgName);&#10;foreach my $snippet (keys %code_vals) {&#10;    $opts-&gt;{$snippet} = "$code_vals{$snippet}";&#10;}&#10;&#10;if (!defined $opts-&gt;{gerrit_server} || $opts-&gt;{gerrit_server} eq "") {&#10;        print "configuration [$cfgName] does not contain a gerrit server name\n";&#10;            exit 1;&#10;}&#10;&#10;## add other parms and values to opts&#10;$opts-&gt;{gerrit_cfg} = "$cfgName";&#10;$opts-&gt;{gerrit_working_dir} = "$[/myResource/gerrit_working_dir]";&#10;$opts-&gt;{changeid} = $cfg-&gt;getProp("/myJob/changeid");&#10;$opts-&gt;{patchid} =  $cfg-&gt;getProp("/myJob/patchid");&#10;$opts-&gt;{project} =  $cfg-&gt;getProp("/myJob/project");&#10;&#10;if (!ElectricCommander::PropMod::loadPerlCodeFromProperty(&#10;    $ec,"/projects/EC-Gerrit-1.1.1.0/scm_driver/ECGerrit") ) {&#10;    print "Could not load ECGerrit.pm\n";&#10;}&#10;&#10;my $gt = new ECGerrit( $ec, &#10;    "$opts-&gt;{gerrit_user}", &#10;    "$opts-&gt;{gerrit_server}", &#10;    "$opts-&gt;{gerrit_port}", &#10;    "$opts-&gt;{gerrit_public_key}", &#10;    "$opts-&gt;{gerrit_private_key}", &#10;    $opts-&gt;{debug});&#10;&#10;###############################################################################&#10;#  &#10;#   API Calls&#10;###############################################################################   &#10;###############################################################################&#10;# Polling&#10;###############################################################################&#10;&#10;###############################################################################&#10;# gr_scanChanges  &#10;#  Aplies the filter for the selected project/branches and sets the changes &#10;#  to be verified&#10;# Args:&#10;#  manifest project/branches (optional) &#10;#  filter (optional)&#10;#   if not args specified we use the config&#10;#&#10;# Returns:&#10;#   $change_str it also sets a property called &#10;# gerrit_changes in cofig&#10;###############################################################################&#10;sub gr_scanChanges {&#10;    my $manifest = shift;&#10;    my $filter = shift;&#10;&#10;    # get all eligible change/patch combinations from Gerrit&#10;    my @changes = $gt-&gt;custom_build($filter,$manifest);&#10;&#10;    if (scalar @changes == 0) {&#10;        print "No changes meet the filter criteria.\n";&#10;        exit 0;&#10;    }&#10;    &#10;        &#10;    # save changes so that code extraction, build, and comments&#10;    # all operate on this list regardeless of other changes&#10;    # that appear in mid flight&#10;    my $change_str = gr_encodeJSON(\@changes);&#10;&#10;    print "===CHANGES===\n";&#10;    print $change_str . "\n";&#10;&#10;    gr_setProperty("changes", $change_str);&#10;    return $change_str;&#10;} &#10;&#10;###############################################################################&#10;# gr_getChanges&#10;#  get the list of changes cached in a property&#10;# &#10;# Args:&#10;#   none&#10;# Returns:&#10;#   array of change records&#10;###############################################################################&#10;sub gr_getChanges {&#10;    return $gt-&gt;getChanges();&#10;}&#10;&#10;###############################&#10;# Dependancy checking routines&#10;###############################&#10;&#10;###############################################################################&#10;#  gr_getChangeMessages&#10;#  reads the commit message of the change and all the comments&#10;#  &#10;#&#10;#   Args:&#10;#     change_id&#10;#   Returns:&#10;#      array with the commit message and all the comments for&#10;#      a given change&#10;############################################################################### &#10;sub gr_getChangeMessages {&#10;    my $id = shift;&#10;    my @commit_msg = $gt-&gt;gerrit_db_query("SELECT SUBJECT FROM CHANGES WHERE CHANGE_ID = '$id';");&#10;    &#10;    if (scalar(@commit_msg) == 0 || "$commit_msg[0]-&gt;{columns}{subject}" eq "") {&#10;        $gt-&gt;showError("No category name for id $id.");&#10;        return "";&#10;    }       &#10;    my $msg = $commit_msg[0]-&gt;{columns}{subject};&#10;    $msg =~ s/ /-/g;&#10;    $msg = lc ($msg);&#10;    my %o_msg;&#10;    $o_msg-&gt;{commit_msg} = $msg;&#10;    &#10;    #get the comments from gerrit&#10;    my @query_comments = $gt-&gt;gerrit_db_query("SELECT MESSAGE FROM CHANGE_MESSAGES WHERE CHANGE_ID = '$id';");&#10;    &#10;    @output = ();    &#10;    push @output,$o_msg; &#10;    foreach (@query_comments){&#10;        my %comment;&#10;        $comment-&gt;{comment} = $_-&gt;{columns}{message}; &#10;        push @output, $comment;      &#10;    }       &#10;       &#10;    $gt-&gt;debugMsg(3,"id=$id commit_msg=$msg");        &#10;    return @output;&#10;}&#10;&#10;###############################################################################&#10;# gr_getChangeStatus&#10;#    reading the status field of a particular change&#10;# Args: &#10;#   id of the change&#10;#   short_mode&#10;#&#10;# Returns:&#10;#   The status of the change  &#10;# NOTE: if short mode is false, it will show the complete word, if not&#10;#   the routine will show the short version of the status &#10;###############################################################################&#10;sub gr_getChangeStatus {&#10;    my $id = shift;&#10;    my $short_mode = shift;&#10;    my @status = $gt-&gt;gerrit_db_query("SELECT STATUS FROM CHANGES WHERE CHANGE_ID = '$id';");&#10;    &#10;    if (scalar(@status) == 0 || "$status[0]-&gt;{columns}{status}" eq "") {&#10;        $gt-&gt;showError("No category name for id $id.");&#10;        return "";&#10;    }   &#10;    $stat = $status[0]-&gt;{columns}{status};&#10;    if ($short_mode == 0 || $short_mode eq ""){&#10;       switch ($stat){&#10;           case('s') { $stat = "Submitted/merge pending"; }&#10;           case('M') { $stat = "Merged"; }&#10;           case('n') { $stat = "Review in progress"; }&#10;           case('A') { $stat = "Abandoned"; }          &#10;       }               &#10;    }&#10;    return $stat;    &#10;}&#10;&#10;###############################################################################&#10;# gr_isIncludedInThisVerificationSet&#10;# determine whether a change is included in the current&#10;# verification set&#10;#&#10;#  Args:&#10;#    change_id&#10;#&#10;#  Returns:&#10;#    true if the change is present in the verification set&#10;#    false if the change is not present in the set&#10;###############################################################################&#10;sub gr_isIncludedInThisVerificationSet {&#10;    my $change_id = shift;&#10;    &#10;    my $str_changes = gr_getProperty("changes");&#10;    my @changes = gr_decodeJSON($str_changes);&#10;    &#10;    if (scalar @changes != 0) {&#10;      &#10;        foreach (@changes) {&#10;            my @change= split(/:/, $_);&#10;            if (@change[0] == $change_id){&#10;               return 1;&#10;            }     &#10;       }             &#10;    }  &#10;    return 0;&#10;}&#10;&#10;&#10;###############################################################################&#10;# Approval&#10;###############################################################################&#10;&#10;###############################################################################&#10;# gr_insertApprovalCategory&#10;#   Add a new aproval category to gerrit, and set the rights&#10;#    &#10;#  NOTE: Gerrit server must be restarted after using this&#10;###############################################################################&#10;sub gr_insertApprovalCategory {&#10;    my ($name, $abb_name, $position, $function_name, &#10;    $copy_min_score,$category_id) = @_;&#10;    &#10;    my $query = 'INSERT INTO APPROVAL_CATEGORIES '&#10;       .'(NAME,ABBREVIATED_NAME,POSITION,FUNCTION_NAME,COPY_MIN_SCORE,CATEGORY_ID) ';&#10;  &#10;    if ($abb_name eq ""){&#10;        $abb = 'NULL';&#10;    }&#10;  &#10;    if ($name ne "") {  &#10;       $query .= "VALUES ('$name',$abb_name,$position,'$function_name','$copy_min_score','$category_id');";&#10;       @result = gr_dbQuery($query);   &#10;       gr_insertRefRights($category_id);&#10;       gr_insertProjectRights($category_id);       &#10;    }&#10;    else {&#10;       $gt-&gt;showError("The category name cannot be null");&#10;    }  &#10;}&#10;&#10;###############################################################################&#10;# gr_insertRefRights&#10;#  Adds the category id into the REF_RIGHTS table&#10;#  Args:&#10;#     $category_id&#10;###############################################################################&#10;&#10;sub gr_insertRefRights {&#10;    my $category_id = shift;&#10;    &#10;    my $query = 'INSERT INTO REF_RIGHTS '&#10;       . '(MIN_VALUE,MAX_VALUE,PROJECT_NAME,REF_PATTERN,CATEGORY_ID,GROUP_ID) ';&#10;    my @result;&#10;    &#10;    if ($category_id ne "") {&#10;        $query .= "VALUES (-1,1,'-- All Projects --','refs/heads/*','$category_id',3);";&#10;        @result = gr_dbQuery($query); &#10;    }&#10;}&#10;&#10;###############################################################################&#10;# gr_insertRefRights&#10;#  Adds the category id into the PROJECT_RIGHTS table&#10;#  Args:&#10;#     $category_id&#10;###############################################################################&#10;&#10;sub gr_insertProjectRights {&#10;    my $category_id = shift;&#10;    &#10;    my $query = 'INSERT INTO PROJECT_RIGHTS '&#10;    . '(MIN_VALUE,MAX_VALUE,PROJECT_NAME,CATEGORY_ID,GROUP_ID) ';&#10;    my @result;&#10;    &#10;    if ($category_id ne "") {&#10;        $query .= "VALUES (-1,1,'-- All Projects --','$category_id',3);";&#10;        @result = gr_dbQuery($query); &#10;    }&#10;}&#10;&#10;###############################################################################&#10;# gr_insertApprovalCategoryValue&#10;#&#10;###############################################################################&#10;sub gr_insertApprovalCategoryValue {&#10;    my ($name,$category_id, $value ) = @_;&#10;    my $query = "INSERT INTO APPROVAL_CATEGORY_VALUES "&#10;       . "(NAME,CATEGORY_ID, VALUE) ";&#10;    &#10;    if ($name ne "") {  &#10;       $query .= "VALUES ('$name','$category_id','$value');";&#10;       @result = gr_dbQuery($query);          &#10;    }&#10;    else {&#10;       $gt-&gt;showError("The category name value cannot be null");&#10;   }  &#10;}&#10;&#10;###############################################################################&#10;# gr_setCustomReviewComment&#10;#   args&#10;#     change_id&#10;###############################################################################&#10;sub gr_setCustomReviewComment{&#10;    my $msg = shift;&#10;    &#10;    gr_setProperty("custom_review_msg", $msg);&#10;}&#10;&#10;&#10;###############################################################################&#10;# MISC Routines&#10;###############################################################################&#10;###############################################################################&#10;# gr_loadPerlCodeFromFile&#10;#  Load and executes the perl code from a file &#10;#  Args:&#10;#    filename&#10;#&#10;#  Returns:&#10;#    true if the execution of the code is succesful &#10;###############################################################################&#10;sub gr_loadPerlCodeFromFile {     &#10;    my $file = shift;&#10;    my $openResult = open( my $fin, $file);&#10;    if (!defined($openResult)) {&#10;        print "could not open $file:$!\n"; &#10;        return 0;&#10;    }&#10;    local $/;&#10;    my $code = &lt;$fin&gt;;&#10;    close $fin;&#10;    if ("$code" eq "") {&#10;        print "Error: could not load perl code from $file\n";&#10;        return 0;&#10;    }   &#10;    eval "$code";&#10;    if ($@) {&#10;        warn $!;&#10;        return 0;&#10;    }   &#10;    return 1;&#10;}&#10;&#10;###############################################################################&#10;# gr_loadTextFile &#10;#   Loads a text file and returns the text&#10;#  &#10;# Args:&#10;#    filename&#10;# Returns:&#10;#    a string with the text&#10;###############################################################################&#10;sub gr_loadTextFile {&#10;    my $file = shift;&#10;    my $openResult = open( my $fin, $file);&#10;    if (!defined($openResult)) {&#10;        print "could not open $file:$!\n"; &#10;        return 0;&#10;    }&#10;    local $/;&#10;    my $text = &lt;$fin&gt;;&#10;    close $fin;&#10;    if ("$text" eq "") {&#10;        print "Error: could not load text from $file\n";&#10;        return 0;&#10;    }   &#10; &#10;    return $text;&#10;}&#10;&#10;###############################################################################&#10;# gr_loadManifest&#10;#   LoadProject/branches manifest from file and store it on a property&#10;#  &#10;# Args:&#10;#    property name in where the text will be stored&#10;#    file path&#10;#    &#10;###############################################################################&#10;sub gr_loadManifest {&#10;   my $property = shift;&#10;   my $filePath = shift;&#10;   &#10;   my $manifest_str = gr_loadTextFile($filePath);&#10;   &#10;   gr_setProperty($property, $manifest_str);   &#10;}&#10;&#10;###############################################################################&#10;#  gr_getProperty&#10;#    Read the content of a property, it only works for properties&#10;#    created using this API&#10;#&#10;#  Args:&#10;#    property name&#10;#  Returns:&#10;#    value&#10;###############################################################################&#10;sub gr_getProperty {&#10;    my $name = shift;&#10;    my $property_value = $cfg-&gt;getProp("/myJob/gerrit_$name");&#10;    return $property_value;&#10;}&#10;&#10;###############################################################################&#10;#  gr_setProperty&#10;#    Sets a new property in the commander&#10;#&#10;#  Args:&#10;#   property name&#10;#   property value&#10;###############################################################################&#10;sub gr_setProperty {&#10;    my $name = shift;&#10;    my $property_value = shift;&#10;    &#10;    $gt-&gt;getCmdr()-&gt;setProperty("/myJob/gerrit_$name", $property_value);&#10;}&#10;&#10;###############################################################################&#10;# gr_encodeJSON &#10;#  Encodes the data to JSON format&#10;# Args:&#10;#   Array of data&#10;# Returns:&#10;#   data string formated in JSON&#10;###############################################################################&#10;sub gr_encodeJSON {&#10;    my @data = shift;&#10;    my $json = JSON-&gt;new-&gt;utf8;&#10;    my $data_str = $json-&gt;encode(@data);    &#10;    return $data_str;&#10;}&#10;&#10;###############################################################################&#10;# gr_decodeJSON&#10;#   Decodes a JSON string &#10;# Args:&#10;#   String data formated in JSON&#10;# Returns:&#10;#   Data array&#10;###############################################################################&#10;sub gr_decodeJSON {&#10;    my $data = shift;&#10;    my $json = JSON-&gt;new-&gt;utf8;&#10;    my $ref = $json-&gt;decode($data);&#10;    return (@$ref);&#10;}&#10;&#10;###############################################################################&#10;# gr_dbQuery&#10;#   Perfroms a query in SQL against the configured gerrit server&#10;#  Args:&#10;#    SQL query&#10;#  Returns:&#10;#    Array of data results &#10;###############################################################################&#10;sub gr_dbQuery{&#10;    my $query = shift;    &#10;    return $gt-&gt;gerrit_db_query($query);&#10;}&#10;&#10;&#10;###############################################################################&#10;# gr_jobStatus&#10;#   Get the status of a given job&#10;#  Args:&#10;#    Job id&#10;#  Returns:&#10;#    true if the job was succesful &#10;###############################################################################&#10;&#10;sub gr_jobStatus{&#10;    my $jobId = shift;&#10;    my $xPath = $ec-&gt;getProperty("/myJob/outcome");&#10;    my $outcome = $xPath-&gt;findvalue('//value')-&gt;string_value;&#10;    &#10;    if ($outcome eq "success"){&#10;        return 1;&#10;    }    &#10;    return 0;&#10;}&#10;</value>
					</property>
					<property>
						<propertyName>preamble</propertyName>
						<description/>
						<expandable>1</expandable>
						<value>use ElectricCommander;&#10;use File::Basename;&#10;use ElectricCommander::PropDB;&#10;use ElectricCommander::PropMod;&#10;&#10;$|=1;&#10;&#10;my $ec = new ElectricCommander();&#10;$ec-&gt;abortOnError(0);&#10;&#10;my $cfgName = "$[gerrit_cfg]";&#10;my $proj = "$[/myProject/projectName]";&#10;my $cfg = new ElectricCommander::PropDB($ec,"/projects/$proj/gerrit_cfgs");&#10;my %vals = $cfg-&gt;getRow($cfgName);&#10;my $opts = \%vals;&#10;&#10;# get pseudo code snippets&#10;my $code = new ElectricCommander::PropDB($ec,"/projects/$proj/gerrit_code");&#10;my %code_vals = $code-&gt;getRow($cfgName);&#10;foreach my $snippet (keys %code_vals) {&#10;    $opts-&gt;{$snippet} = "$code_vals{$snippet}";&#10;}&#10;&#10;if (!defined $opts-&gt;{gerrit_server} || $opts-&gt;{gerrit_server} eq "") {&#10;        print "configuration [$cfgName] does not contain a gerrit server name\n";&#10;            exit 1;&#10;}&#10;&#10;## add other parms and values to opts&#10;$opts-&gt;{gerrit_cfg} = "$cfgName";&#10;$opts-&gt;{gerrit_working_dir} = "$[/myResource/gerrit_working_dir]";&#10;$opts-&gt;{changeid} = $cfg-&gt;getProp("/myJob/changeid");&#10;$opts-&gt;{patchid} =  $cfg-&gt;getProp("/myJob/patchid");&#10;$opts-&gt;{project} =  $cfg-&gt;getProp("/myJob/project");&#10;&#10;if (!ElectricCommander::PropMod::loadPerlCodeFromProperty(&#10;    $ec,"/myProject/scm_driver/ECGerrit") ) {&#10;    print "Could not load ECGerrit.pm\n";&#10;}&#10;&#10;my $gt = new ECGerrit( $ec, &#10;    "$opts-&gt;{gerrit_user}", &#10;    "$opts-&gt;{gerrit_server}", &#10;    "$opts-&gt;{gerrit_port}", &#10;    "$opts-&gt;{gerrit_public_key}", &#10;    "$opts-&gt;{gerrit_private_key}", &#10;    $opts-&gt;{debug});&#10;&#10;</value>
					</property>
				</propertySheet>
			</property>
			<property>
				<propertyName>pseudo_code</propertyName>
				<description>Property sheet to hold pseudo code snippets</description>
				<propertySheet>
					<property>
						<propertyName>cmd_clone</propertyName>
						<expandable>1</expandable>
						<value></value>
					</property>
					<property>
						<propertyName>cmd_magic_dir</propertyName>
						<expandable>1</expandable>
						<value>.repo</value>
					</property>
					<property>
						<propertyName>cmd_overlay</propertyName>
						<description/>
						<expandable>1</expandable>
						<value></value>
					</property>
					<property>
						<propertyName>cmd_revert</propertyName>
						<expandable>1</expandable>
						<value></value>
					</property>
					<property>
						<propertyName>cmd_update</propertyName>
						<expandable>1</expandable>
						<value></value>
					</property>
					<property>
						<propertyName>repo_cmd</propertyName>
						<expandable>1</expandable>
						<value>repo</value>
					</property>
				</propertySheet>
			</property>
			<property>
				<propertyName>scm_driver</propertyName>
				<description>Home for perl code</description>
				<propertySheet>
					<property>
						<propertyName>ECGerrit</propertyName>
						<description>ECGerrit.pm</description>
						<expandable>0</expandable>
						<value>####################################################################&#10;#&#10;# ECGerrit&#10;#   A perl package to encapsulatei interaction with the&#10;#   gerrit code review tool&#10;#&#10;####################################################################&#10;package ECGerrit;&#10;&#10;$::gApproveCmd = "review";&#10;&#10;$|=1;&#10;&#10;# get JSON from the plugin directory&#10;if ("$ENV{COMMANDER_PLUGIN_PERL}" ne "") {&#10;    # during tests&#10;    push @INC, "$ENV{COMMANDER_PLUGIN_PERL}";&#10;} else {&#10;    # during production&#10;    push @INC, "$ENV{COMMANDER_PLUGINS}/EC-Gerrit-1.1.1.0/agent/perl";&#10;    #push @INC, "$ENV{COMMANDER_PLUGINS}/EC-Gerrit-1.0.1.0/agent/perl";&#10;}&#10;require JSON;&#10;&#10;use URI::Escape;&#10;use Net::SSH2;&#10;use File::Basename;&#10;use IO::Socket;&#10;use MIME::Base64;&#10;use ElectricCommander;&#10;use ElectricCommander::PropDB;&#10;&#10;####################################################################&#10;# Object constructor for ECGerrit&#10;#&#10;# Inputs&#10;#   sshurl = the gerrit server  (ssh://user@host:port)&#10;#   dbg    = debug level (0-3)&#10;####################################################################&#10;sub new {&#10;    my $class = shift;&#10;&#10;    my $self = {&#10;        _cmdr    =&gt; shift,&#10;        _user    =&gt; shift,&#10;        _server  =&gt; shift,&#10;        _port    =&gt; shift,&#10;        _ssh_pub =&gt; shift,&#10;        _ssh_pvt =&gt; shift,&#10;        _dbg     =&gt; shift,&#10;    };&#10;&#10;    bless ($self, $class);&#10;    return $self;&#10;}&#10;&#10;######################################&#10;# getCmdr&#10;#&#10;# Get the commander object&#10;######################################&#10;sub getCmdr {&#10;    my $self = shift;&#10;    return $self-&gt;{_cmdr};&#10;}&#10;&#10;######################################&#10;# getServer&#10;#&#10;# Get the server&#10;######################################&#10;sub getServer {&#10;    my $self = shift;&#10;    if (!defined $self-&gt;{_server} ||&#10;        $self-&gt;{_server} eq "") {&#10;        # default to localhost&#10;        return "localhost";&#10;    } else {&#10;        return $self-&gt;{_server};&#10;    }&#10;}&#10;&#10;######################################&#10;# getUser&#10;#&#10;# Get the user&#10;######################################&#10;sub getUser {&#10;    my $self = shift;&#10;    if (!defined $self-&gt;{_user} ||&#10;        $self-&gt;{_user} eq "") {&#10;        # default to commander&#10;        return "commander";&#10;    } else {&#10;        return $self-&gt;{_user};&#10;    }&#10;}&#10;&#10;######################################&#10;# getPort&#10;#&#10;# Get the Port&#10;######################################&#10;sub getPort {&#10;    my $self = shift;&#10;    if (!defined $self-&gt;{_port} ||&#10;        $self-&gt;{_port} eq "") {&#10;        # default to gerrit default&#10;        return "29418";&#10;    } else {&#10;        return $self-&gt;{_port};&#10;    }&#10;}&#10;&#10;######################################&#10;# getSSHPvt&#10;#&#10;# Get the Port&#10;######################################&#10;sub getSSHPvt {&#10;    my $self = shift;&#10;    return $self-&gt;{_ssh_pvt};&#10;}&#10;&#10;######################################&#10;# getSSHPub&#10;#&#10;# Get the Port&#10;######################################&#10;sub getSSHPub {&#10;    my $self = shift;&#10;    return $self-&gt;{_ssh_pub};&#10;}&#10;&#10;######################################&#10;# getDbg&#10;#&#10;# Get the Dbg level&#10;######################################&#10;sub getDbg {&#10;    my $self = shift;&#10;    if (!defined $self-&gt;{_dbg} ||&#10;        $self-&gt;{_dbg} eq "") {&#10;        return 0;&#10;    } else {&#10;        return $self-&gt;{_dbg};&#10;    }&#10;}&#10;&#10;######################################&#10;# gerrit_db_query&#10;#&#10;# parse output of gerrit db query&#10;#&#10;# Gerrit queries are run through the &#10;# ssh host gerrit gsql command which&#10;# returns data in JSON format. &#10;#&#10;# Depending on the query, results could&#10;# be large (too large to hold in mem)&#10;# so be carefull with the query &#10;#&#10;# args&#10;#   opertation = a SQL string&#10;#&#10;# returns&#10;#   results  - array of results&#10;#&#10;# example&#10;#  my ($exit,@results) = $self-&gt;gerrit_db_query("SELECT * FROM ACCOUNTS;");&#10;#  print @results[0]-&gt;{columns}{ssh_user_name};&#10;#&#10;######################################&#10;sub gerrit_db_query {&#10;    my $self = shift;&#10;    my $operation = shift;&#10;&#10;    my @sqlout = ();&#10;&#10;    my $gcmd = "gerrit gsql --format JSON";&#10;&#10;    my $input = "$operation\n\\q\n";&#10;    #my $input = "$operation";&#10;    $self-&gt;debugMsg(3,"========command =========");&#10;    $self-&gt;debugMsg(3, $operation);&#10;    $self-&gt;debugMsg(3,"========raw output ======");&#10;    my ($exit,$out) = $self-&gt;runCmd("$gcmd","$input");&#10;    if ($exit != 0 ) {&#10;        # if command did not succeed we should exit&#10;        # this is drastic, but if query command is not working &#10;        # something fundamental is wrong with setup&#10;        $self-&gt;showMsg("$out");&#10;        $self-&gt;showError("error running command $gcmd ($exit)");&#10;    }&#10;    $self-&gt;debugMsg(3, $out);&#10;&#10;    my $row = 0;&#10;    my (@lines) = split(/\n/,$out);&#10;    foreach my $line (@lines) {&#10;        my $json = JSON-&gt;new-&gt;utf8;&#10;        my $arr = $json-&gt;decode($line);&#10;        push @sqlout, $arr;&#10;        $row++;&#10;    }&#10;&#10;    # remove the statistics record&#10;    #   {"type":"query-stats","rowCount":3,"runTimeMilliseconds":1}&#10;    if (scalar(@sqlout) &gt; 0) {&#10;        pop @sqlout;&#10;    }&#10;&#10;    $self-&gt;debugMsg(3, "table found $row rows");&#10;    return @sqlout;&#10;}   &#10;&#10;##########################################&#10;# trimstr&#10;#   trim leading and trailing whitespace&#10;# &#10;# args&#10;#   intput string&#10;#&#10;# returns&#10;#   trimmed output string&#10;##########################################&#10;sub trimstr {&#10;    my $self = shift;&#10;    my $string = shift;&#10;    $string =~ s/^\s+//;&#10;    $string =~ s/\s+$//;&#10;    return $string;&#10;}&#10;&#10;&#10;##########################################&#10;# getChangeComments&#10;#   get the comments for a change&#10;# &#10;# args&#10;#   change - change id&#10;#&#10;# returns&#10;#   table - table of results&#10;#&#10;##########################################&#10;sub getChangeComments {&#10;    my $self = shift;&#10;    my $changeid = shift;&#10;    my @empty = ();&#10;    if (!defined $changeid || "$changeid" eq "") {&#10;        $self-&gt;showError("no changeid passed to getChangeComments");&#10;        return @empty;&#10;    }&#10;    # must have something after MESSAGE or the limited parser will not work&#10;    return ($self-&gt;gerrit_db_query(&#10;        "select MESSAGE,UUID from CHANGE_MESSAGES where CHANGE_ID = '$changeid';"));&#10;}&#10;&#10;##########################################&#10;# getAccountId&#10;#   get the AccountId for the gerrit user&#10;# &#10;# args&#10;#   user - user name&#10;#&#10;# returns&#10;#   id - numeric AccountId or user&#10;#&#10;##########################################&#10;sub getAccountId {&#10;    my $self = shift;&#10;    my $user = shift;&#10;    if (!defined $user || "$user" eq "") {&#10;        $self-&gt;showError ("no user passed to getUserId");&#10;        return undef;&#10;    }&#10;    my @tmp = $self-&gt;gerrit_db_query(&#10;        "select ACCOUNT_ID from ACCOUNTS where SSH_USER_NAME = '$user';");&#10;    if (scalar(@tmp) == 0 || "$tmp[0]-&gt;{columns}{account_id}" eq "") {&#10;        $self-&gt;showError( "No account found for user $user.");&#10;        return "";&#10;    }&#10;    return $tmp[0]-&gt;{columns}{account_id};&#10;}&#10;&#10;##########################################&#10;# getTime&#10;#   format at time string&#10;# &#10;# args&#10;#   none&#10;#&#10;# returns&#10;#   time string&#10;##########################################&#10;sub getTime {&#10;    my $self = shift;&#10;    my $string;&#10;    my ($sec,$min,$hour,$mday,$mon,$year,$wday,&#10;    $yday,$isdst)=localtime(time);&#10;    $string = sprintf( "%4d-%02d-%02d %02d:%02d:%02.3f",&#10;        $year+1900,$mon+1,$mday,$hour,$min,$sec);&#10;    return $string;&#10;}&#10;&#10;##########################################&#10;# computeUUID&#10;#   key field for messages is a computed&#10;#   uuid based on the sequence&#10;#   CHANGE_MESSAGE_ID. This computes the &#10;#   uuid string&#10;# &#10;# NOT NEEDED NOW THAT WE ARE USING COMMAND LINE&#10;# FOR APPROVALS. LEFT HERE IN CASE WE NEED IT&#10;# AGAIN&#10;#&#10;# args&#10;#   key - numeric key value&#10;#&#10;# returns&#10;#   uuid string&#10;##########################################&#10;sub computeUUID {&#10;    my $self = shift;&#10;    my $key = shift;&#10;    my $seq=0x7FFFFFFF;&#10;    my $num = pack('NN',$key,$seq);&#10;    my $string = encode_base64($num);&#10;    chomp $string;&#10;    return $string;&#10;}&#10;&#10;###################################################&#10;# getOpenChanges&#10;#&#10;# Get a list of open changes for this&#10;# project/branch&#10;#&#10;# args&#10;#   project - project of interest (optional)&#10;#   branch  - branch of interest&#10;# &#10;# returns&#10;#   result - array from query results&#10;###################################################&#10;sub getOpenChanges {&#10;    my ($self,$proj,$branch) = @_;&#10;&#10;    my @result;&#10;    my $destbranch = "refs/heads/$branch";&#10;    my $query = "SELECT * from CHANGES WHERE"&#10;        . " DEST_BRANCH_NAME = '$destbranch'"&#10;        . " AND OPEN = 'Y'";&#10;    if ("$proj" ne "") {&#10;        $query .= " AND DEST_PROJECT_NAME = '$proj'";&#10;    }&#10;    $query .= ";";&#10;    return ($self-&gt;gerrit_db_query($query));&#10;}&#10;&#10;###################################################&#10;# getOpenChangesForTeamBuild&#10;#&#10;# Get a list of open changes for a list of&#10;# projects/branches&#10;#&#10;# args&#10;#   array of project:branches strings (separated by colon)&#10;#   &#10;# &#10;# returns&#10;#   result - array from query results&#10;###################################################&#10;sub getOpenChangesForTeamBuild {&#10;    my ($self,@projects_branches) = @_;&#10;    my @result;    &#10;    my $query = "SELECT * from CHANGES WHERE (";    &#10;    my $i = 0;&#10;    my $size = scalar @projects_branches;&#10;    &#10;    foreach my $manifest_project (@projects_branches) {&#10;        @info = split /:/, $manifest_project;&#10;        my $proj = @info[0];&#10;        my $branch = @info[1];       &#10;      &#10;        chomp $proj, $branch;&#10;        my $destbranch = "refs/heads/$branch";&#10;        &#10;        if (($i &gt; 0) &amp;&amp; ($i &lt; $size)) {&#10;           $query .= "\n OR \n";&#10;           }      &#10;        $i++;&#10;       &#10;        $query .= "(";&#10;        $query .= "DEST_BRANCH_NAME = '$destbranch'"&#10;             .  " AND OPEN = 'Y'";&#10;        if ("$proj" ne "") {&#10;            $query .= " AND DEST_PROJECT_NAME = '$proj'";&#10;        }&#10;    &#10;        $query .= ')';         &#10;    }  &#10;    $query .= ');';&#10;    return ($self-&gt;gerrit_db_query($query));&#10;}&#10;&#10;################################################&#10;# testECState&#10;#&#10;# Tests if a change/patchid has been marked in a &#10;# particualr state by the commander integration&#10;# This is done by looking in the comments. &#10;# The EC integration will  add comments to &#10;# document what has been done.&#10;# &#10;# comment form&#10;# ec:change:patch:state notes&#10;#&#10;# Examples:&#10;#   job run for this patchid&#10;#   ec:1:1:jobRunning 3453 http://....&#10;#&#10;#   job finished for this patchid&#10;#   ec:1:1:jobComplete success http://...&#10;#&#10;# args&#10;#   changeid - numeric changeid&#10;#   patchid - numeric patchid&#10;#   state - state to test&#10;#       valid: jobAvailable jobRunning jobComplete&#10;# &#10;# returns&#10;#   0 - not found&#10;#   uuid of CHANGE_MESSAGES row if found&#10;#&#10;#################################################&#10;sub testECState {&#10;    my $self = shift;&#10;    my $changeid = shift;&#10;    my $patchid = shift;&#10;    my $state    = shift;&#10;&#10;    $self-&gt;debugMsg(2, "testECState...c=$changeid p=$patchid s=$state");&#10;    if (!defined $changeid || !defined $patchid || !defined $state ||&#10;        "$changeid" eq "" || "$patchid" eq "" ) {&#10;        $self-&gt;showError("bad arguments to testECState");&#10;        return 0;&#10;    }&#10;    # get all comments for this changeset &#10;    # comments are not indexed by patchid&#10;    my @changes = $self-&gt;getChangeComments($changeid) ;&#10;    if (!@changes) {&#10;        return 0;&#10;    }&#10;    # look for magic string&#10;    my $numComments = scalar(@changes);&#10;    foreach my $row (@changes) {&#10;        my $msg = $row-&gt;{columns}{message};&#10;        if ($msg =~ m/ec\:$changeid\:$patchid\:$state/) {&#10;            $self-&gt;debugMsg(2, "testECState found state set");&#10;            return $row-&gt;{columns}{uuid};&#10;        }&#10;    }&#10;    $self-&gt;debugMsg(2, "testECState found state not set");&#10;    return 0;&#10;}&#10;  &#10;################################################&#10;# setECState&#10;#&#10;# marks a change/patchid for  commander integration&#10;# &#10;# comment form&#10;# ec:change:patch:state notes&#10;#&#10;# args&#10;#   project   - gerrit project &#10;#   changeid  - numeric changeid&#10;#   patchid   - numeric patchid&#10;#   state     -  state to add&#10;#       valid: jobRunning jobComplete jobAvailable&#10;#   notes - other text to include in message&#10;#   category  - the category for approve (optional)&#10;#   value o   - the value for approve (optional)&#10;# &#10;#################################################&#10;sub setECState {&#10;    my $self = shift;&#10;    my $project  = shift;&#10;    my $changeid = shift;&#10;    my $patchid  = shift;&#10;    my $state    = shift;&#10;    my $notes    = shift;&#10;    my $category = shift || "";&#10;    my $value    = shift || "";&#10;&#10;    $self-&gt;debugMsg(1,"setECState...$changeid,$patchid s=$state n=$notes c=$category v=$value");&#10;    if (!defined $self || !defined $changeid || &#10;        !defined $patchid || !defined $state ||&#10;        "$changeid" eq "" || "$patchid" eq "" || \&#10;        "$state" eq "") {&#10;        $self-&gt;showError( "bad arguments to setECState");&#10;        return 0;&#10;    }&#10;&#10;    my $result;&#10;    my $msg = "$notes    ec:$changeid:$patchid:$state";&#10;    return $self-&gt;approve($project,$changeid, $patchid,$msg,$category,$value);&#10;}&#10;&#10;#################################################&#10;#################################################&#10;# team_build&#10;#################################################&#10;#################################################&#10;sub team_build {    &#10;    my ($self, $rules, $filename) = @_;&#10;     &#10;    $rules =~ s/^'//g;&#10;    $rules =~ s/'$//g;&#10;    $self-&gt;debugMsg(2,"rules:$rules");&#10;&#10;    my ($filters,$actions) = $self-&gt;parseRules($rules);&#10;    @project_branches = $self-&gt;parseManifest($filename);&#10;    #my @changes  = $self-&gt;getOpenChanges($project,$branch);&#10;    my @changes  = $self-&gt;getOpenChangesForTeamBuild(@project_branches);&#10;    my ($metrics,$idmap) = $self-&gt;get_team_build_metrics(@changes);&#10;    my @eligible = $self-&gt;get_eligible_changes($filters,$metrics,$idmap);&#10;&#10;    if ($self-&gt;getDbg()) {&#10;        $self-&gt;print_filters($filters);&#10;        $self-&gt;print_actions($actions);&#10;        $self-&gt;print_metrics($metrics);&#10;        $self-&gt;print_changes(@changes);&#10;        $self-&gt;print_idmap($idmap);&#10;        $self-&gt;print_eligible(@eligible);&#10;    }&#10;        &#10;    return @eligible;&#10;}&#10;&#10;#################################################&#10;#################################################&#10;# custom_build&#10;#################################################&#10;#################################################&#10;sub custom_build {&#10;    my ($self, $rules, $manifest) = @_;&#10;     &#10;    $rules =~ s/^'//g;&#10;    $rules =~ s/'$//g;&#10;    $self-&gt;debugMsg(2,"rules:$rules");&#10;&#10;    my ($filters,$actions) = $self-&gt;parseRules($rules);&#10;    @project_branches = $self-&gt;parseManifestStr($manifest);    &#10;    my @changes  = $self-&gt;getOpenChangesForTeamBuild(@project_branches);&#10;    &#10;    my ($metrics,$idmap) = $self-&gt;get_team_build_metrics(@changes);&#10;    my @eligible = $self-&gt;get_eligible_changes($filters,$metrics,$idmap);&#10;&#10;    if ($self-&gt;getDbg()) {&#10;        $self-&gt;print_filters($filters);&#10;        $self-&gt;print_actions($actions);&#10;        $self-&gt;print_metrics($metrics);&#10;        $self-&gt;print_changes(@changes);&#10;        $self-&gt;print_idmap($idmap);&#10;        $self-&gt;print_eligible(@eligible);&#10;    }&#10;        &#10;    return @eligible;&#10;}&#10;&#10;#################################################&#10;# team_appprove&#10;#################################################&#10;sub team_approve {&#10;    my ($self,$changes,$rules,$msg) = @_;&#10;    return $self-&gt;team_approve_base($changes, $rules, "SUCCESS",$msg);&#10;}&#10;&#10;#################################################&#10;# team_annotate&#10;#################################################&#10;sub team_annotate {&#10;    my ($self,$changes,$msg) = @_;&#10;    return $self-&gt;team_approve_base($changes, "", "",$msg);&#10;}&#10;&#10;#################################################&#10;# team_disappprove&#10;#################################################&#10;sub team_disapprove {&#10;    my ($self,$changes,$rules,$msg) = @_;&#10;    return $self-&gt;team_approve_base($changes, $rules, "ERROR",$msg);&#10;}&#10;&#10;#################################################&#10;# team_approve_base&#10;#################################################&#10;sub team_approve_base {&#10;    my ($self,$changes,$rules, $state, $msg) = @_;&#10;&#10;    my $category = "";&#10;    my $value    = "";&#10;    if ("$rules" ne "") {&#10;        my ($filters,$actions) = $self-&gt;parseRules($rules);&#10;        # lookup the category, value, and user from the &#10;        # team_build_rules&#10;        $category = $actions-&gt;{$state}{CAT};&#10;        $value    = $actions-&gt;{$state}{VAL};&#10;    }&#10;&#10;    $self-&gt;debugMsg(2,"approve");&#10;    $self-&gt;debugMsg(2,"category = $category");&#10;    $self-&gt;debugMsg(2,"value    = $value");&#10;&#10;    foreach my $str (@$changes) {&#10;        my ($changeid, $patchid,$project) = split (/:/,$str);&#10;        $self-&gt;approve($project, $changeid, $patchid, $msg, $category,$value);&#10;    }&#10;    return ;&#10;}&#10;&#10;##########################################&#10;# approve&#10;#   add comment and/or set approval &#10;#      using gerrit approve command&#10;# &#10;# args&#10;#   project - the project  (optional)&#10;#   changeid - the changeset id&#10;#   patchid - the patchset id&#10;#   msg - the message to include&#10;#   category - the CATEGORY to set in approval  (optional)&#10;#   value - the value to set  (optional)&#10;#&#10;# returns&#10;#   exit code of running approve command&#10;##########################################&#10;sub approve {&#10;    my ($self,$project, $changeid, $patchid, $msg, $category,$value) = @_;&#10;&#10;&#10;    my $gcmd = "gerrit $::gApproveCmd $changeid,$patchid '--message=$msg'";&#10;&#10;    if ($project &amp;&amp; "$project" ne "") {&#10;        $gcmd .= " '--project=$project'";&#10;    }&#10;&#10;    if ($category &amp;&amp; "$category" ne "") {&#10;        my $category_option = $self-&gt;get_category_name($category);&#10;        if ("$category_option" eq "") {&#10;            $self-&gt;showError( "Could not find category name for $category");&#10;            return;&#10;        }&#10;        $gcmd .= " --$category_option=$value";&#10;    }&#10;&#10;    $self-&gt;debugMsg(2,"approve cmd:$gcmd");&#10;&#10;    # run the approve command&#10;    my ($exit,$out) = $self-&gt;runCmd($gcmd,"");&#10;    $self-&gt;showMsg($out);&#10;    return $exit;&#10;}&#10;    &#10;&#10;#################################################&#10;# get_eligible_changes&#10;#&#10;# process filters, changes, and metrics to &#10;# pull out the set of changes that should&#10;# be built&#10;#&#10;# Inputs&#10;#   changes - list of candidate changes&#10;#   filters- map of user specified filters&#10;#   metrics - map of user/category/min/max/counts&#10;#&#10;# Return&#10;#   list of change:patch numbers that should be built&#10;#&#10;#################################################&#10;sub get_eligible_changes {&#10;    my ($self,$filters, $metrics,$idmap) = @_;&#10;&#10;    my @eligble;&#10;    foreach my $changeid (keys % {$metrics}) {&#10;        # check filters against metrics&#10;        $self-&gt;debugMsg(1, "---Checking change $changeid against filters ---");&#10;        if ($self-&gt;check_filters($filters, $metrics-&gt;{$changeid} )) {&#10;            ## add change/patch to eligible list&#10;            my $patchid = $idmap-&gt;{$changeid}{patchid};&#10;            my $project = $idmap-&gt;{$changeid}{project};&#10;            $self-&gt;debugMsg(1, "...hit $changeid:$patchid");&#10;            push (@eligible, "$changeid:$patchid:$project");&#10;        } else {&#10;            $self-&gt;debugMsg(1, "...miss $changeid:$patchid");&#10;        }&#10;    }&#10;    return @eligible;&#10;}&#10;&#10;&#10;#################################################&#10;# get_team_build_metrics&#10;#&#10;# Search through comments for a project, branch&#10;# and find max/min/count of different category &#10;# comments&#10;#&#10;# Input&#10;#     filters - map of filters&#10;#################################################&#10;sub get_team_build_metrics {&#10;    my ($self,@changes) = @_;&#10;&#10;    my $metrics = ();&#10;    my $idmap = ();&#10;&#10;    foreach my $change (@changes) {&#10;        my $changeid = $change-&gt;{columns}{change_id};&#10;        my $project  = $change-&gt;{columns}{dest_project_name};&#10;        my @max = $self-&gt;gerrit_db_query("SELECT MAX(PATCH_SET_ID) FROM"&#10;            . " PATCH_SETS WHERE CHANGE_ID = '$changeid';");&#10;        my $patchid = $max[0]-&gt;{columns}{'max(patch_set_id)'};&#10;        $idmap-&gt;{$changeid}{patchid} = "$patchid";&#10;        $idmap-&gt;{$changeid}{project} = "$project";&#10;&#10;        $metrics-&gt;{$changeid}{""}{$cat}{COUNT} = 0;&#10;        $metrics-&gt;{$changeid}{""}{$cat}{MAX}   = 0;&#10;        $metrics-&gt;{$changeid}{""}{$cat}{MIN}   = 0;&#10;&#10;        # find all approvals for highest patchset for change&#10;        my @approvals = $self-&gt;gerrit_db_query("SELECT * FROM PATCH_SET_APPROVALS WHERE CHANGE_OPEN = 'Y'"&#10;            . " AND CHANGE_ID = '$changeid' AND PATCH_SET_ID = '$patchid';");&#10;        foreach my $approval (@approvals) {&#10;            my $cat      = $approval-&gt;{columns}{category_id};&#10;            my $user     = $self-&gt;get_user($approval-&gt;{columns}{account_id} );&#10;            my $value    = $approval-&gt;{columns}{value};&#10;&#10;            $metrics-&gt;{$changeid}{""}{$cat}{COUNT} += 1;&#10;            if (!defined $metrics-&gt;{$changeid}{""}{$cat}{MIN}  ||&#10;                $value &lt; $metrics-&gt;{$changeid}{""}{$cat}{MIN} ) {&#10;                $metrics-&gt;{$changeid}{""}{$cat}{MIN} = $value;&#10;            }&#10;            if (!defined $metrics-&gt;{$changeid}{""}{$cat}{MAX}  ||&#10;                $value &gt; $metrics-&gt;{$changeid}{""}{$cat}{MAX} ) {&#10;                $metrics-&gt;{$changeid}{""}{$cat}{MAX} = $value;&#10;            }&#10;            $metrics-&gt;{$changeid}{$user}{$cat}{COUNT} += 1;&#10;            if (!defined $metrics-&gt;{$changeid}{$user}{$cat}{MIN}  ||&#10;                $value &lt; $metrics-&gt;{$changeid}{$user}{$cat}{MIN} ) {&#10;                $metrics-&gt;{$changeid}{$user}{$cat}{MIN} = $value;&#10;            }&#10;            if (!defined $metrics-&gt;{$changeid}{$user}{$cat}{MAX} ||&#10;                $value &gt; $metrics-&gt;{$changeid}{$user}{$cat}{MAX} ) {&#10;                $metrics-&gt;{$changeid}{$user}{$cat}{MAX}= $value;&#10;            }&#10;        }&#10;    }&#10;    return ($metrics,$idmap);&#10;}&#10;&#10;&#10;############################################################&#10;# check_filters&#10;#&#10;# Process filters with metrics to see if rules in &#10;# filters pass. If they do, return 1, otherwise&#10;# return 0&#10;#&#10;# Input&#10;#   filters and metrics maps&#10;# Returns&#10;#   1 if all filters pass, 0 otherwies&#10;############################################################&#10;sub check_filters {&#10;    my ($self,$filters, $metrics) = @_;&#10;&#10;    # for each filter&#10;    my $result = 1;&#10;    foreach my $num (sort keys % {$filters}) {&#10;        if ($filters-&gt;{$num}{TYPE} =~ /MAX/) { &#10;            $result = $self-&gt;check_max($filters-&gt;{$num},$metrics); &#10;        }&#10;        if ($filters-&gt;{$num}{TYPE} =~ /MIN/) { &#10;            $result = $self-&gt;check_min($filters-&gt;{$num},$metrics); &#10;        }&#10;        if ($filters-&gt;{$num}{TYPE} =~ /COUNT/) { &#10;            $result = $self-&gt;check_count($filters-&gt;{$num},$metrics); &#10;        }&#10;        if  (!$result) { last; }&#10;    }&#10;    return $result;&#10;}&#10;&#10;############################################################&#10;# check_max&#10;#&#10;# Check a filter of type max &#10;#&#10;# Input&#10;#   fitlers map&#10;#   metrics map&#10;# Returns&#10;#   1 if filter pass, 0 otherwies&#10;############################################################&#10;sub check_max {&#10;    my ($self,$filter,$metrics) = @_;&#10;    my $cat     = $filter-&gt;{CAT};&#10;    my $op      = $filter-&gt;{OP};&#10;    my $val     = $filter-&gt;{VAL};&#10;    my $user_op = $filter-&gt;{USER_OP};&#10;    my $user    = $filter-&gt;{USER};&#10;    # get the maximum value&#10;    my $max = 0;&#10;    if ("$user_op" eq "") {&#10;        $max = $metrics-&gt;{""}{$cat}{MAX} || 0;&#10;    } elsif ($user_op eq "eq") {&#10;        $max = $metrics-&gt;{$user}{$cat}{MAX} || 0;&#10;    } elsif ($user_op eq "ne") {&#10;        # take max of all users except $user&#10;        my $usermax = undef;&#10;        foreach my $ruser (keys % {$metrics}) {&#10;            # skip the ne user&#10;            if ($ruser = "$user") { next;}&#10;            if (!defined $usermax || $metrics-&gt;{$user}{$cat}{MAX} &gt; $usermax ) {&#10;                $usermax = $metrics-&gt;{$user}{$cat}{MAX} || 0;&#10;            }&#10;        }&#10;        $max = $usermax;&#10;    }&#10;    # check max against filter&#10;    my $expr = "$max $op $val";&#10;    my $result = eval $expr;&#10;    $self-&gt;debugMsg(1,"...MAX $cat $op $val $user_op $user , max=$max, result=$result");&#10;    return $result;&#10;}&#10;&#10;############################################################&#10;# check_min&#10;#&#10;# Check a filter of type min &#10;#&#10;# Input&#10;#   fitlers map&#10;#   metrics map&#10;# Returns&#10;#   1 if filter pass, 0 otherwies&#10;############################################################&#10;sub check_min {&#10;    my ($self,$filter,$metrics) = @_;&#10;    my $cat     = $filter-&gt;{CAT};&#10;    my $op      = $filter-&gt;{OP};&#10;    my $val     = $filter-&gt;{VAL};&#10;    my $user_op = $filter-&gt;{USER_OP};&#10;    my $user    = $filter-&gt;{USER};&#10;    # get the maximum value&#10;    my $min = 0;&#10;    if ("$user_op" eq "") {&#10;        $min = $metrics-&gt;{""}{$cat}{MIN} || 0;&#10;    } elsif ($user_op eq "eq") {&#10;        $min = $metrics-&gt;{$user}{$cat}{MIN} || 0;&#10;    } elsif ($user_op eq "ne") {&#10;        # take min of all users except $user&#10;        my $usermin = undef;&#10;        foreach my $ruser (keys % {$metrics}) {&#10;            # skip the ne user&#10;            if ($ruser = "$user") { next;}&#10;            if (!defined $usermin || $metrics-&gt;{$user}{$cat}{MIN} &lt; $usermax ) {&#10;                $usermin = $metrics-&gt;{$user}{$cat}{MIN} || 0;&#10;            }&#10;        }&#10;        $min = $usermin;&#10;    }&#10;    # check min against filter&#10;    my $expr = "$min $op $val";&#10;    my $result = eval $expr;&#10;    $self-&gt;debugMsg(1,"...MIN $cat $op $val $user_op $user , min=$min, result=$result");&#10;    return $result;&#10;}&#10;&#10;############################################################&#10;# check_count&#10;#&#10;# Check a filter of type count &#10;#&#10;# Input&#10;#   fitlers map&#10;#   metrics map&#10;# Returns&#10;#   1 if filter pass, 0 otherwies&#10;############################################################&#10;sub check_count {&#10;    my ($self,$filter,$metrics) = @_;&#10;    my $cat     = $filter-&gt;{CAT};&#10;    my $op      = $filter-&gt;{OP};&#10;    my $val     = $filter-&gt;{VAL};&#10;    my $user_op = $filter-&gt;{USER_OP};&#10;    my $user    = $filter-&gt;{USER};&#10;    # get the count value&#10;    my $count = 0;&#10;    if ("$user_op" eq "") {&#10;        $count = $metrics-&gt;{""}{$cat}{COUNT} || 0;&#10;    } elsif ($user_op eq "eq") {&#10;        $count = $metrics-&gt;{$user}{$cat}{COUNT} || 0;&#10;    } elsif ($user_op eq "ne") {&#10;        # take max of all users except $user&#10;        my $usercount = 0;&#10;        foreach my $ruser (keys % {$metrics}) {&#10;            # skip the ne user&#10;            if ($ruser = "$user") { next;}&#10;            $usercount += $metrics-&gt;{$user}{$cat}{COUNT} || 0;&#10;        }&#10;        $count = $usercount;&#10;    }&#10;    # check max against filter&#10;    my $expr = "$count $op $val";&#10;    my $result = eval $expr;&#10;    $self-&gt;debugMsg(1,"...COUNT $cat $op $val $user_op $user , count=$count, result=$result");&#10;    return $result;&#10;}&#10;&#10;############################################################&#10;# get_user&#10;#&#10;# finds the ssh user name for a given account_id&#10;#&#10;# Args:&#10;#   id - a gerrit account id&#10;#&#10;# Returns&#10;#   string - the ssh_user configured for the account_id&#10;############################################################&#10;sub get_user {&#10;    my ($self,$id) = @_;&#10;    my @accounts = $self-&gt;gerrit_db_query("SELECT SSH_USER_NAME FROM ACCOUNTS WHERE ACCOUNT_ID = '$id';");&#10;    if (scalar(@accounts) == 0 || "$accounts[0]-&gt;{columns}{ssh_user_name}" eq "") {&#10;        $self-&gt;showError("No account found for user $id.");&#10;        return "";&#10;    }&#10;    my $user = $accounts[0]-&gt;{columns}{ssh_user_name};&#10;    $self-&gt;debugMsg(3,"id=$id user=$user");&#10;    return $user;&#10;}&#10;&#10;############################################################&#10;# get_category_name&#10;#&#10;# finds the category name from category id&#10;#&#10;# Args:&#10;#   id - a category id&#10;#&#10;# Returns&#10;#   string - the category name suitable as an approve option&#10;#            it is all lowercase with spaces converted to -&#10;############################################################&#10;sub get_category_name {&#10;    my ($self,$id) = @_;&#10;    my @cats = $self-&gt;gerrit_db_query("SELECT NAME FROM APPROVAL_CATEGORIES  WHERE CATEGORY_ID = '$id';");&#10;    if (scalar(@cats) == 0 || "$cats[0]-&gt;{columns}{name}" eq "") {&#10;        $self-&gt;showError("No category name for id $id.");&#10;        return "";&#10;    }&#10;    my $name = $cats[0]-&gt;{columns}{name};&#10;    $name =~ s/ /-/g;&#10;    $name = lc ($name);&#10;    $self-&gt;debugMsg(3,"id=$id name=$name");&#10;    return $name;&#10;}&#10;&#10;############################################################&#10;# parseRules&#10;#&#10;# read in a blob of config text and parse into &#10;# filter and action maps&#10;#&#10;# Args:&#10;#   blob - string to process&#10;#&#10;# Returns&#10;#   filters,actions maps&#10;############################################################&#10;sub parseRules {&#10;    my ($self,$blob) = @_;&#10;    my $filters = ();&#10;    my $actions = ();&#10;    my @lines = split (/\n/,$blob);&#10;    my $num = 0;&#10;    $self-&gt;debugMsg(3,"parsing rules:$blob");&#10;    foreach my $line (@lines ) {&#10;        if ($line =~ /^#/) { next;}&#10;        if ($line =~ /^[\s]*$/) { next;}&#10;        my @tokens = split (/ /, $line);&#10;        if ($line =~ /^FILTER/) {&#10;            my $type    = @tokens[1];&#10;            my $cat     = @tokens[2];&#10;            my $op      = @tokens[3];&#10;            my $val     = @tokens[4];&#10;            my $userflg = @tokens[5];&#10;            my $user_op = @tokens[6];&#10;            my $user    = @tokens[7];&#10;            $self-&gt;debugMsg(3,"parsing FILTER:$type $cat $op $val $user_op $user");&#10;            if ("$type" ne "MAX" &amp;&amp; "$type" ne "MIN" &amp;&amp;&#10;                "$type" ne "COUNT" ) {&#10;                $self-&gt;showError("FILTER ($type) must be MAX, MIN, or COUNT");&#10;                $self-&gt;showError($line);&#10;                next;&#10;            }&#10;            if ("$op" ne "ge" &amp;&amp; "$op" ne "eq" &amp;&amp;&#10;                "$op" ne "gt" &amp;&amp; "$op" ne "lt" &amp;&amp;&#10;                "$op" ne "le" &amp;&amp; "$op" ne "ne") {&#10;                $self-&gt;showError("FILTER operation ($op) must be one of:eq ne lt le gt ge");&#10;                $self-&gt;showError($line);&#10;                next;&#10;            }&#10;            if ("$val" eq "" ) {&#10;                $self-&gt;showError("FILTER value is blank.");&#10;                $self-&gt;showError($line);&#10;                next;&#10;            }&#10;            if ("$userflg" eq "USER" ) {&#10;                if ("$user_op" ne "eq" &amp;&amp; "$user_op" ne "ne") {&#10;                    $self-&gt;showError("USER op ($user_op) must be one of:eq ne");&#10;                    $self-&gt;showError($line);&#10;                    next;&#10;                }&#10;                if ("$user" eq "") {&#10;                    $self-&gt;showError("user name not found");&#10;                    $self-&gt;showError($line);&#10;                    next;&#10;                }&#10;            }&#10;            $filters-&gt;{$num}{TYPE} = $type;&#10;            $filters-&gt;{$num}{TYPE} = $type;&#10;            $filters-&gt;{$num}{CAT} = $cat;&#10;            $filters-&gt;{$num}{OP} = $op;&#10;            $filters-&gt;{$num}{VAL} = $val;&#10;            $filters-&gt;{$num}{USER_OP} = $user_op;&#10;            $filters-&gt;{$num}{USER} = $user;&#10;            $num++;&#10;        }&#10;        if ($line =~ /^ACTION/) {&#10;            my $state   = @tokens[1];&#10;            my $cat     = @tokens[2];&#10;            my $val     = @tokens[3];&#10;            $self-&gt;debugMsg(3, "parsing ACTION:$state $cat $val");&#10;            if ("$state" ne "ERROR" &amp;&amp; "$state" ne "SUCCESS") {&#10;                $self-&gt;showError("ACTION ($state) must be SUCCESS or ERROR");&#10;                $self-&gt;showError($line);&#10;                next;&#10;            }&#10;            if ("$cat" eq "" || "$val" eq "" ) {&#10;                $self-&gt;showError("ACTION category and value are required");&#10;                $self-&gt;showError($line);&#10;                next;&#10;            }&#10;            $actions-&gt;{$state}{CAT} = $cat;&#10;            $actions-&gt;{$state}{VAL} = $val;&#10;        }&#10;    }&#10;    return ($filters,$actions);&#10;}&#10;&#10;############################################################&#10;# parseManifest&#10;#&#10;# read projects and branches from file to be used by the scan &#10;# function&#10;#&#10;# Args:&#10;#   filename&#10;#&#10;# Returns&#10;#   hash with the pairs project branch name&#10;############################################################&#10;sub parseManifest{&#10;    my ($self,$fileName) = @_;&#10;    &#10;    if ($::gRunCmdUseFakeOutput){&#10;      my @fakeOutput = ("platform/cts:master");&#10;      return @fakeOutput;&#10;    }    &#10;    $self-&gt;debugMsg(3,"Parsing manifest file:$filename");&#10;    open FILE, $fileName or die "Could not open the manifest file, check the path in the configuration settings";&#10;    my @lines = &lt;FILE&gt;;   &#10;    my @output;&#10;    my $size = scalar @lines;    &#10;    my $c = 0; &#10;    foreach $line (@lines){&#10;        chomp($line);&#10;        if ($line ne ""){&#10;            @info = split /:/, $line;&#10;                  &#10;            if (!defined @info[1])  {                &#10;                @output[$c] = @info[0] . ":master";                &#10;                $c++;                &#10;            } &#10;            else{                &#10;                @output[$c] = @info[0] . ":" . @info[1];              &#10;                $c++;&#10;            }    &#10;       }&#10;    }&#10;    #the file is empty we send the default values&#10;    if ($size &lt;= 0){&#10;        @output[0] =":master";&#10;    }&#10;    close (FILE);   &#10;    return @output;&#10;    &#10;}&#10;&#10;############################################################&#10;# parseManifestStr&#10;#&#10;# read projects and branches from file to be used by the scan &#10;# function&#10;#&#10;# Args:&#10;#   manifest str&#10;#&#10;# Returns&#10;#   hash with the pairs project branch name&#10;############################################################&#10;sub parseManifestStr{&#10;    my ($self,$manifest_str) = @_;&#10;    &#10;    if ($manifest_str ne ""){&#10;       $self-&gt;debugMsg(3,"Parsing manifest: $manifest_str");&#10;    }    &#10;&#10;    my @lines = split(/\n/, $manifest_str);  &#10;    my @output;&#10;    my $size = scalar @lines;       &#10;    my $c = 0; &#10;    foreach $line (@lines){&#10;        chomp($line);&#10;        if ($line ne ""){&#10;            @info = split /:/, $line;&#10;                  &#10;            if (!defined @info[1])  {                &#10;                @output[$c] = @info[0] . ":master";                &#10;                $c++;                &#10;            } &#10;            else{                &#10;                @output[$c] = @info[0] . ":" . @info[1];              &#10;                $c++;&#10;            }    &#10;       }&#10;    }&#10;    #the file is empty we send the default values&#10;    if ($size &lt;= 0){&#10;        @output[0] =":master";&#10;        $self-&gt;debugMsg(3,"No manifest string supplied, we assumed master branch by default.\n");&#10;    }&#10;     &#10;    return @output;&#10;}&#10;&#10;############################################################&#10;# replace_strings&#10;#&#10;# replace keywords in strings.&#10;#&#10;# Args:&#10;#   instring - string to scan&#10;#   map - a map of replacements &#10;#&#10;# Returns&#10;#   instring with keywords replaced&#10;############################################################&#10;sub replace_strings {&#10;    my ($self,$instring,$map) = @_;&#10;    foreach my $str (keys % {$map}) {&#10;        $instring =~ s/$str/$map-&gt;{$str}/g;&#10;    }&#10;    return $instring;&#10;}&#10;&#10;############################################################&#10;# getChanges&#10;#&#10;# get the list of changes cached in a property&#10;#&#10;# Returns&#10;#   array of change records&#10;############################################################&#10;sub getChanges {&#10;    my ($self) = @_;&#10;    my @changes=();&#10;    my $cfg = new ElectricCommander::PropDB($self-&gt;getCmdr(),"");&#10;    my $change_str = $cfg-&gt;getProp("/myJob/gerrit_changes");&#10;    if (!defined $change_str || "$change_str" eq "") {&#10;        return @changes;&#10;    }   &#10;    $self-&gt;debugMsg(2,"Changes:$change_str");&#10;    my $json = JSON-&gt;new-&gt;utf8;&#10;    my $ref = $json-&gt;decode($change_str);&#10;    return (@$ref);&#10;}&#10;&#10;#############################################################&#10;# runCmd: run a command&#10;#                                                           &#10;# cmdin - the command to run&#10;# input - the text to pipe into cmd (optional)&#10;#&#10;# returns&#10;#   exitstatus - exit code of command&#10;#   text       - stdout of command&#10;#############################################################&#10;sub runCmd {&#10;    my $self  = shift;&#10;    my $cmd   = shift;&#10;    my $input = shift;&#10;&#10;    ## for test, if canned output is given, pop off&#10;    ## the next output block and return&#10;    if ($::gRunCmdUseFakeOutput) {&#10;        if ("$::gFakeCmdOutput" eq "") {&#10;            # we ran out of fake output&#10;            return (99,"no more output");&#10;        }&#10;        my @lines = split(/\|\|/, "$::gFakeCmdOutput");&#10;        my $text = shift (@lines);&#10;        my ($exitstatus,$out) = split(/\:\:/,$text);&#10;        chomp $exitstatus;&#10;&#10;        # push remaining text &#10;        my $newv = join ("\|\|", @lines);&#10;        $::gFakeCmdOutput = $newv;&#10;        return ($exitstatus,$out);&#10;    }   &#10;&#10;    my $c = $self-&gt;ssh_connect(&#10;        $self-&gt;getServer(),&#10;        $self-&gt;getUser(),&#10;        $self-&gt;getPort(),&#10;        $self-&gt;getSSHPub,&#10;        $self-&gt;getSSHPvt,&#10;        );&#10;        &#10;    $self-&gt;debugMsg(4,"runCmd:$cmd\ninput:$input\n");&#10;    my ($exit,$out) = $self-&gt;ssh_runCommand($c,$cmd,$input);&#10;    return ($exit,$out);&#10;&#10;}&#10;&#10;############################################################&#10;# makeReplacementMap&#10;#&#10;# make a map out of all opts suitable for use in&#10;# replacement calls (replaceStrings)&#10;#&#10;# Returns&#10;#   the hashmap&#10;############################################################&#10;sub makeReplacementMap {&#10;    my $self = shift;&#10;    my $map = (); &#10;    foreach my $opt (keys % {$opts}) {&#10;        $map-&gt;{"{$opt}"} = "$opts-&gt;{$opt}";&#10;    }   &#10;    return $map;&#10;}&#10;&#10;############################################################&#10;# SCAN FUNCTIONS&#10;############################################################&#10;&#10;###################################################&#10;# processNewChanges&#10;#&#10;# find new gerrit changes that this integration has not &#10;# previously processed and process them&#10;#&#10;# args&#10;#   opts - configuration options&#10;# &#10;# returns&#10;#   nothing&#10;###################################################&#10;sub processNewChanges {&#10;    my $self = shift;&#10;    my $opts = shift;&#10;    my @project_branches = $self-&gt;parseManifest($opts-&gt;{"teambuild_project_branches"});&#10;    &#10;    #foreach my $manifest_project (keys % {$projects_branches}) {&#10;    foreach $line (@project_branches){&#10;        @info = split /:/, $line;&#10;        my $proj = @info[0];&#10;        my $branch = @info[1];      &#10;      &#10;        chomp $proj, $branch;&#10;        $opts-&gt;{"gerrit_project"} = $proj;&#10;        $opts-&gt;{"gerrit_branch"} =  $branch;&#10;        $self-&gt;processSingleProject($opts);&#10;    }&#10;}&#10;&#10;###################################################&#10;# processSingleProject&#10;#&#10;# find new gerrit changes that this integration has not &#10;# previously processed and process them&#10;#&#10;# args&#10;#   opts - configuration options&#10;# &#10;# returns&#10;#   nothing&#10;###################################################&#10;sub processSingleProject{&#10;    my $self = shift;&#10;    my $opts = shift;&#10;    $self-&gt;showMsg("Processing new gerrit changes for project $opts-&gt;{gerrit_project}"&#10;        . " and branch $opts-&gt;{gerrit_branch}...");&#10;    &#10;    # Get list of all open changes    &#10;    my @ch = $self-&gt;getOpenChanges("$opts-&gt;{gerrit_project}", "$opts-&gt;{gerrit_branch}");&#10;    if (!@ch) {&#10;        $self-&gt;showMsg( "No changes found.");&#10;        return;&#10;    }&#10;    foreach my $row (@ch) {&#10;        my $changeid = $row-&gt;{columns}{change_id};&#10;        my $patchid = $row-&gt;{columns}{current_patch_set_id};&#10;        my $project = $row-&gt;{columns}{dest_project_name};&#10;               &#10;        $self-&gt;showMsg( "Found change $changeid:$patchid");&#10;        &#10;        # see if any of them need processing&#10;        my $uuid = 0;&#10;        my $state = "jobRunning";&#10;        if ($opts-&gt;{devbuild_mode} eq "auto") {&#10;            $state = "jobCompleted";&#10;            $uuid += $self-&gt;testECState($changeid,$patchid,$state);&#10;            $state = "jobRunning";&#10;            $uuid += $self-&gt;testECState($changeid,$patchid,$state);&#10;        } else {&#10;            $state = "jobAvailable";&#10;            $uuid += $self-&gt;testECState($changeid,$patchid,$state);&#10;        }&#10;        if ($uuid) {&#10;            $self-&gt;debugMsg(1, "Already processed change=$changeid patchset=$patchid");&#10;            next;&#10;        } &#10;        $self-&gt;showMsg( "Processing change=$changeid patchset=$patchid");&#10;&#10;        # create a comment&#10;        my $msg = "";&#10;        if ($opts-&gt;{devbuild_mode} eq "auto") {&#10;            # run a job too&#10;            $self-&gt;showMsg ("Running job for $changeid:$patchid");&#10;            $msg = $self-&gt;launchECJob($opts,$changeid,$patchid,$project);&#10;        } else {&#10;            # just put a link in comment for building&#10;            $self-&gt;showMsg("Creating a link to run a job for $changeid:$patchid");&#10;            $msg = "This change can be built with ElectricCommander. "&#10;                . "https://$opts-&gt;{cmdr_webserver}/commander/link/runProcedure/projects/"&#10;                . uri_escape($opts-&gt;{devbuild_cmdr_project}) . "/procedures/"&#10;                . uri_escape($opts-&gt;{devbuild_cmdr_procedure}) . "?"&#10;                . "&amp;numParameters=4"&#10;                . "&amp;parameters1_name=gerrit_cfg"&#10;                . "&amp;parameters1_value="&#10;                . uri_escape($opts-&gt;{gerrit_cfg})&#10;                . "&amp;parameters2_name=changeid"&#10;                . "&amp;parameters2_value=$changeid"&#10;                . "&amp;parameters3_name=project"&#10;                . "&amp;parameters3_value=$project"&#10;                . "&amp;parameters4_name=patchid"&#10;                . "&amp;parameters4_value=$patchid";&#10;        }&#10;        # DevBuildPrepare::annotate should do this...&#10;        #$self-&gt;setECState($project,$changeid, $patchid, $state, $msg, "","");&#10;    }&#10;}&#10;&#10;###################################################&#10;# launchECJob&#10;#&#10;# Launch a new EC job to test these changes&#10;#&#10;# args&#10;#   opts - configuration options&#10;#   changeid - change id of changes&#10;#   patchid  - patchid of changes&#10;# &#10;# returns&#10;#   msg - message to put in gerrit comment&#10;###################################################&#10;sub launchECJob {&#10;    my $self = shift;&#10;    my $opts = shift;&#10;    my $changeid = shift;&#10;    my $patchid = shift;&#10;    my $project = shift;&#10;&#10;    my $xPath = $self-&gt;getCmdr()-&gt;runProcedure($opts-&gt;{devbuild_cmdr_project} ,&#10;        { procedureName =&gt; $opts-&gt;{devbuild_cmdr_procedure}, &#10;          actualParameter =&gt; [&#10;            {actualParameterName =&gt; 'changeid', value =&gt; "$changeid" },&#10;            {actualParameterName =&gt; 'patchid', value =&gt; "$patchid" },&#10;            {actualParameterName =&gt; 'project', value =&gt; "$project" },&#10;            {actualParameterName =&gt; 'gerrit_cfg', value =&gt; "$opts-&gt;{gerrit_cfg}" },&#10;          ]&#10;        });&#10;    my $msg = "";&#10;    my $errcode = $xPath-&gt;findvalue('//responses/error/code')-&gt;string_value;&#10;    if (defined $errcode &amp;&amp; "$errcode" ne "") {&#10;        my $errmsg = $xPath-&gt;findvalue('//responses/error/message')-&gt;string_value;&#10;        $msg = "ElectricCommander tried but could not run a job for this change. [$errcode]";&#10;    } else {&#10;        my $jobId = $xPath-&gt;findvalue('//responses/response/jobId')-&gt;string_value;&#10;        # Mark the change as processed&#10;        $msg = "This change is being built with ElectricCommander. "&#10;            . "https://$opts-&gt;{cmdr_webserver}/commander/link/jobDetails/jobs/$jobId";&#10;    }&#10;    return $msg;&#10;}&#10;&#10;###################################################&#10;# processFinishedJobs&#10;#&#10;# find jobs that were started by this integration&#10;# and if complete, mark them in gerrit comments&#10;#&#10;# args&#10;#   opts - configuration options&#10;# &#10;# returns&#10;#   nothing&#10;###################################################&#10;sub processFinishedJobs {&#10;    my $self = shift;&#10;    my $opts = shift;&#10;&#10;    $self-&gt;showMsg("Processing finished jobs...");&#10;    if (!defined $opts) {&#10;        $self-&gt;showError("bad arguments to processFinishedJobs");&#10;        return;&#10;    }&#10;    my @filter,@selects;&#10;    push (@filter, {"propertyName" =&gt; "status",&#10;                    "operator" =&gt; "equals",&#10;                    "operand1" =&gt; "completed"});&#10;    push (@filter, {"propertyName" =&gt; "projectName",&#10;                    "operator" =&gt; "equals",&#10;                    "operand1" =&gt; $opts-&gt;{devbuild_cmdr_project}});&#10;    push (@filter, {"propertyName" =&gt; "procedureName",&#10;                    "operator" =&gt; "equals",&#10;                    "operand1" =&gt; $opts-&gt;{devbuild_cmdr_procedure}});&#10;    push (@filter, {"propertyName" =&gt; "processed_by_gerrit",&#10;                    "operator" =&gt; "notEqual",&#10;                    "operand1" =&gt; "done"});&#10;&#10;    push (@selects, {"propertyName" =&gt; "outcome"});&#10;    push (@selects, {"propertyName" =&gt; "branch"});&#10;    push (@selects, {"propertyName" =&gt; "changeid"});&#10;    push (@selects, {"propertyName" =&gt; "patchid"});&#10;    push (@selects, {"propertyName" =&gt; "project"});&#10;    push (@selects, {"propertyName" =&gt; "gerrit_cfg"});&#10;&#10;    # get list of jobs that are finished but not recorded&#10;    # this should be a relatively small list&#10;    # only returns objectId's&#10;    my $xPath = $self-&gt;getCmdr()-&gt;findObjects("job", {numObjects =&gt; "0",     &#10;        filter =&gt; \@filter, select =&gt; \@selects});&#10;    {&#10;        my $errcode = $xPath-&gt;findvalue('//responses/error/code')-&gt;string_value;&#10;        if (defined $errcode &amp;&amp; "$errcode" ne "") {&#10;            my $errmsg = $xPath-&gt;findvalue('//responses/error/message')-&gt;string_value;&#10;            $self-&gt;showError("error [$errcode] when searching jobs. $errmsg");&#10;            return;&#10;        }&#10;    }&#10;&#10;    # for each job found&#10;    my $objectNodeset = $xPath-&gt;find('//response/objectId');&#10;    foreach my $node ($objectNodeset-&gt;get_nodelist)&#10;    {&#10;        my $objectId = $node-&gt;string_value();&#10;        # get the details&#10;        my $jPath = $self-&gt;getCmdr()-&gt;getObjects({objectId =&gt; $objectId, select =&gt; \@selects});&#10;        {&#10;            my $errcode = $jPath-&gt;findvalue('//responses/error/code')-&gt;string_value;&#10;            if (defined $errcode &amp;&amp; "$errcode" ne "") {&#10;                my $errmsg = $jPath-&gt;findvalue('//responses/error/message')-&gt;string_value;&#10;                $self-&gt;showError("error [$errcode] when looking up object #$objectid. $errmsg");&#10;                next;&#10;            }&#10;        }&#10;        # load up all the properties found&#10;        my $props;&#10;        my $on = $jPath-&gt;find('//responses/response/object/property');&#10;        foreach my $n ($on-&gt;get_nodelist) {&#10;            my $name= $n-&gt;findvalue('propertyName')-&gt;string_value;&#10;            my $value= $n-&gt;findvalue('value')-&gt;string_value;&#10;            $props-&gt;{$name} = "$value";&#10;            $self-&gt;debugMsg(1, "props{$name}=$props-&gt;{$name}");&#10;        }&#10;&#10;        my $jobId= $jPath-&gt;findvalue('//jobId')-&gt;string_value;&#10;        my $outcome= $jPath-&gt;findvalue('//outcome')-&gt;string_value;&#10;&#10;        $self-&gt;showMsg("Found job $jobId for"&#10;            . " change=$props-&gt;{changeid} patchset=$props-&gt;{patchid}"&#10;            . " completed with outcome $outcome");&#10;        # mark as done&#10;        $self-&gt;getCmdr()-&gt;setProperty("/jobs/$jobId/processed_by_gerrit","done");&#10;&#10;        # sanity check this job&#10;        if (!defined $props-&gt;{changeid} || $props-&gt;{changeid} eq "" || &#10;          !($props-&gt;{changeid} =~ /^(\d+\.?\d*|\.\d+)$/) ) {&#10;            $self-&gt;debugMsg(1, "changeid[$props-&gt;{changeid}] for job $jobId is invalid");&#10;            next;&#10;        }&#10;        # get rules from config&#10;        my $cfg = new ElectricCommander::PropDB($self-&gt;getCmdr(),"/myProject/gerrit_cfgs");&#10;        my $rules = $cfg-&gt;getCol($props-&gt;{gerrit_cfg},"dev_build_rules");&#10;        my ($filters, $actions) = $self-&gt;parseRules("$rules");&#10;        my $cat   = "";&#10;        my $value = "";&#10;        if ($outcome eq "success") {&#10;            $cat   = $actions-&gt;{SUCCESS}{CAT} || "";&#10;            $value = $actions-&gt;{SUCCESS}{VAL} || "";&#10;            $msg   = "This change was successfully built with ElectricCommander. "&#10;                . "https://$opts-&gt;{cmdr_webserver}/commander/link/jobDetails/jobs/$jobId";&#10;        } else {&#10;            $cat   = $actions-&gt;{ERROR}{CAT} || "";&#10;            $value = $actions-&gt;{ERROR}{VAL} || "";&#10;            $msg   = "This change failed the ElectricCommander build. "&#10;                . "https://$opts-&gt;{cmdr_webserver}/commander/link/jobDetails/jobs/$jobId";&#10;        }&#10;        $self-&gt;setECState("$props-&gt;{project}","$props-&gt;{changeid}", &#10;            "$props-&gt;{patchid}","jobComplete", $msg, $cat, $value);&#10;    }&#10;    return;&#10;}&#10;&#10;###################################################&#10;# cleanup&#10;#&#10;# remove previous runs of the scanner job&#10;#&#10;# args&#10;#   opts - configuration options&#10;# &#10;# returns&#10;#   nothing&#10;###################################################&#10;sub cleanup {&#10;    my $self = shift;&#10;&#10;    # Check for the OS Type&#10;    my $osIsWindows = $^O =~ /MSWin/;&#10;    my $cfg = new ElectricCommander::PropDB($self-&gt;getCmdr(),"");&#10;&#10;    my $projectName   = $cfg-&gt;getProp("/plugins/EC-Gerrit/projectName");&#10;    my $procedureName = "DeveloperScan";&#10;    my $scheduleName  = "Gerrit New Change Scanner";&#10;&#10;    #  Find all previous runs of this job&#10;    my @filterList;&#10;    push (@filterList, {"propertyName" =&gt; "projectName",&#10;                        "operator" =&gt; "equals",&#10;                        "operand1" =&gt; "$projectName"});&#10;    push (@filterList, {"propertyName" =&gt; "procedureName",&#10;                        "operator" =&gt; "equals",&#10;                        "operand1" =&gt; "$procedureName"});&#10;    push (@filterList, {"propertyName" =&gt; "status",&#10;                        "operator" =&gt; "equals",&#10;                        "operand1" =&gt; "completed"});&#10;&#10;    # Delete only the jobs that this SCHEDULE started (unless deleteAll specified)&#10;    push (@filterList, {"propertyName" =&gt; "scheduleName",&#10;                        "operator" =&gt; "equals",&#10;                        "operand1" =&gt; "$scheduleName"});&#10;&#10;    push (@filterList, {"propertyName" =&gt; "outcome",&#10;                        "operator" =&gt; "notEqual",&#10;                        "operand1" =&gt; "error"});&#10;&#10;    # Run the Query&#10;    my $xPath = $self-&gt;getCmdr()-&gt;findObjects(&#10;        "job", {numObjects =&gt; "500", filter =&gt; \@filterList });&#10;&#10;    # Loop over all returned jobs&#10;    my $nodeset = $xPath-&gt;find('//job');&#10;    foreach my $node ($nodeset-&gt;get_nodelist)&#10;    {&#10;        #  Find the workspaces (there can be more than one if some steps&#10;        #  were configured to use a different workspace&#10;        my $jobId = $xPath-&gt;findvalue('jobId', $node);&#10;        my $jobName = $xPath-&gt;findvalue('jobName', $node);&#10;        my $xPath = $self-&gt;getCmdr()-&gt;getJobInfo($jobId);&#10;        my $wsNodeset = $xPath-&gt;find('//job/workspace');&#10;        foreach my $wsNode ($wsNodeset-&gt;get_nodelist) {&#10;            my $workspace;&#10;            if ($osIsWindows)&#10;            {&#10;                $workspace = $xPath-&gt;findvalue('./winUNC', $wsNode);&#10;                $workspace =~ s/\/\//\\\\/g;&#10;            }&#10;            else&#10;            {&#10;                $workspace = $xPath-&gt;findvalue('./unix', $wsNode);&#10;            }&#10;&#10;            # Delete the workspace (after checking its name as a sanity test)&#10;            # look for "job_nnn" or "ElectricSentry-nnn"&#10;            if ($workspace =~ /[-_][\d]+$/)&#10;            {&#10;                use File::Path;&#10;&#10;                rmtree ([$workspace]) ;&#10;                $self-&gt;showMsg( "Deleted workspace - $workspace");&#10;            }&#10;        }&#10;&#10;        # Delete the job&#10;&#10;        my $xPath = $self-&gt;getCmdr()-&gt;deleteJob($jobId);&#10;        $self-&gt;showMsg( "Deleted job - $jobName");&#10;    }&#10;}&#10;###############################################&#10;# error routines&#10;###############################################&#10;&#10;###############################################&#10;# showError&#10;#&#10;# print an error and quit&#10;#&#10;# args&#10;#   msg  - the message to show&#10;#   code - if present, exit with this code&#10;#&#10;###############################################&#10;sub showError {&#10;    my $self = shift;&#10;    my $msg  = shift;&#10;    my $code = shift;&#10;&#10;    print STDERR "Error: $msg\n";&#10;    if (defined $code) {&#10;        exit $code;&#10;    }&#10;}&#10;&#10;###############################################&#10;# showMsg&#10;#&#10;# print a message&#10;#&#10;# args&#10;#   msg  - the message to show&#10;#&#10;###############################################&#10;sub showMsg {&#10;    my $self = shift;&#10;    my $msg  = shift;&#10;&#10;    print "$msg\n";&#10;}&#10;&#10;###############################################&#10;# debugMsg&#10;#&#10;# print a message if debug level permits&#10;#&#10;# args&#10;#   lvl  - the debug level for this message&#10;#   msg  - the message to show&#10;#&#10;###############################################&#10;sub debugMsg {&#10;    my $self = shift;&#10;    my $lvl  = shift;&#10;    my $msg  = shift;&#10;&#10;    if ($self-&gt;getDbg() &gt;= $lvl) {&#10;        print "$msg\n";&#10;    }&#10;}&#10;&#10;###############################################&#10;# Debugging routines&#10;###############################################&#10;&#10;###############################################&#10;# printAllTables&#10;#&#10;# enumerates all tables in schema, loads them&#10;# into perl hashes and prints contents&#10;#&#10;# could result in very large datasets&#10;# should only be used in development&#10;# on small gerrit dbs&#10;###############################################&#10;sub printAllTables {&#10;    my $self = shift;&#10;    my @tables = $self-&gt;gerrit_db_query("\\d");&#10;    $self-&gt;print_table(@tables);&#10;    my $rows = scalar(@tables);&#10;    for (my $index=0; $index &lt; $rows; $index++) {&#10;        my @tbl = $self-&gt;gerrit_db_query("select * from " .&#10;            $tables[$index]-&gt;{columns}{table_name} . ";");&#10;        $self-&gt;print_table(@tbl);&#10;    }&#10;}&#10;&#10;##########################################&#10;# print_table&#10;#   print the results of a query&#10;# &#10;# args&#10;#   array returned from gerrit_db_query&#10;#&#10;# returns&#10;#   nothing&#10;##########################################&#10;sub print_table {&#10;    my ($self,@table) = @_;&#10;    print "========table =========\n"; &#10;    my $row=0;&#10;    foreach my $row (@table) {&#10;        foreach my $col (keys % {$row}) {&#10;            print "row[$row]-&gt;{$col}=$row-&gt;{$col}\n";&#10;        }&#10;        $row++;&#10;    }&#10;}&#10;&#10;############################################################&#10;# print_filters&#10;#&#10;# For debugging, prints out a filters map&#10;#&#10;# Args:&#10;#   filters -  a filters map&#10;#&#10;# Returns&#10;#   prints out contents of filters map&#10;############################################################&#10;sub print_filters {&#10;    my ($self,$filters) = @_;&#10;&#10;    # for each filter&#10;    print "--FILTERS--\n";&#10;    foreach my $num (sort keys % {$filters}) {&#10;        print "filter $num: type=$filters-&gt;{$num}{TYPE}"&#10;            . " cat=$filters-&gt;{$num}{CAT}"&#10;            . " op=$filters-&gt;{$num}{OP}"&#10;            . " num=$filters-&gt;{$num}{VAL}"&#10;            . " user_op=$filters-&gt;{$num}{USER_OP}"&#10;            . " user=$filters-&gt;{$num}{USER} \n";&#10;    }&#10;&#10;}&#10;&#10;############################################################&#10;# print_actions&#10;#&#10;# For debugging, prints out a actions map&#10;#&#10;# Args:&#10;#   actions -  a actions map&#10;#&#10;# Returns&#10;#   prints out contents of actions map&#10;############################################################&#10;sub print_actions {&#10;    my ($self,$actions) = @_;&#10;&#10;    print "--ACTIONS--\n";&#10;    print "action SUCCESS: "&#10;        . " $actions-&gt;{SUCCESS}{CAT}"&#10;        . " $actions-&gt;{SUCCESS}{USER}\n";&#10;    print "action ERROR: "&#10;        . " $actions-&gt;{ERROR}{CAT}"&#10;        . " $actions-&gt;{ERROR}{USER}\n";&#10;}&#10;&#10;############################################################&#10;# print_metrics&#10;#&#10;# For debugging, prints out a metrics map&#10;#&#10;# Args:&#10;#   metrics -  a metrics map&#10;#&#10;# Returns&#10;#   prints out contents of metrics map&#10;############################################################&#10;sub print_metrics {&#10;    my ($self,$metrics) = @_;&#10;&#10;    # for each user&#10;    print "--METRICS--\n";&#10;    foreach my $changeid (keys % {$metrics}) {&#10;        print "---change $changeid ---\n";&#10;        foreach my $user (sort keys % {$metrics-&gt;{$changeid}}) {&#10;            foreach my $cat (sort keys %{$metrics-&gt;{$changeid}{$user}}) {&#10;                print "metric: user=$user category=$cat"&#10;                    . " min=$metrics-&gt;{$changeid}{$user}{$cat}{MIN}"&#10;                    . " max=$metrics-&gt;{$changeid}{$user}{$cat}{MAX}"&#10;                    . " count=$metrics-&gt;{$changeid}{$user}{$cat}{COUNT}\n";&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;############################################################&#10;# print_changes&#10;#&#10;# For debugging, prints out a changes array&#10;#&#10;# Args:&#10;#   changes -  a changes array&#10;#&#10;# Returns&#10;#   prints out contents of changes array&#10;############################################################&#10;sub print_changes {&#10;    my ($self,@changes) = @_;&#10;&#10;    # for each user&#10;    print "--CHANGES--\n";&#10;    foreach my $change (@changes) {&#10;        print "Change " . $change-&gt;{columns}{change_id} . "\n";&#10;    }&#10;}&#10;&#10;############################################################&#10;# print_eligible&#10;#&#10;# For debugging, prints out a eligible array&#10;#&#10;# Args:&#10;#   eligible -  a eligible map&#10;#&#10;# Returns&#10;#   prints out contents of eligible array&#10;############################################################&#10;sub print_eligible {&#10;    my ($self,@eligible) = @_;&#10;&#10;    # for each change&#10;    print "--ELIGIBLE LIST--\n";&#10;    foreach my $changestr (@eligible) {&#10;        my ($c,$patch,$proj) = split(/:/,$changestr);&#10;        print "$c:$patch:$proj\n";&#10;    }&#10;}&#10;&#10;############################################################&#10;# print_idmap&#10;#&#10;# For debugging, prints out a idmap map&#10;#&#10;# Args:&#10;#   eligible -  a idmap map&#10;#&#10;# Returns&#10;#   prints out contents of patchid map&#10;############################################################&#10;sub print_idmap {&#10;    my ($self,$idmap) = @_;&#10;&#10;    # for each change&#10;    print "--PATCH SET IDS--\n";&#10;    foreach my $changeid (keys % {$idmap}) {&#10;        print "$changeid:$idmap-&gt;{$changeid}{patchid}:$idmap-&gt;{$changeid}{project}\n";&#10;    }&#10;}&#10;&#10;####################### SSH Operation Implementations #########################&#10;&#10;# ------------------------------------------------------------------------&#10;# ssh_getDefaultTargetPort&#10;#&#10;#      Returns the default target port for this protocol.&#10;#&#10;# Arguments:&#10;#      None&#10;# ------------------------------------------------------------------------&#10;&#10;sub ssh_getDefaultTargetPort() {&#10;    return 29418;&#10;}&#10;&#10;# ------------------------------------------------------------------------&#10;# ssh_connect&#10;#&#10;#      Opens a connection to the proxy target via ssh.&#10;#&#10;# Arguments:&#10;#      host   - Name or IP address of the proxy target.&#10;#      port   - (optional) Port to connect to.  Defaults to 22.&#10;# ------------------------------------------------------------------------&#10;&#10;sub ssh_connect {&#10;    my ($self,$host, $userName, $port, $pubKeyFile, $privKeyFile) = @_;&#10;&#10;    # Be sure that pubKeyFile, and privKeyFile are defined and that the two&#10;    # files actually exist.  Error out otherwise.&#10;&#10;    $pubKeyFile || die "ssh_connect: Public key file must be specified; use " .&#10;            "setSSHKeyFiles\n";&#10;&#10;    if (! -r $pubKeyFile) {&#10;        die "ssh_connect: Public key file '$pubKeyFile' does not exist or " .&#10;            "is not readable\n";&#10;    }&#10;&#10;    $privKeyFile || die "ssh_connect: Private key file must be specified; " .&#10;        "use setSSHKeyFiles\n";&#10;&#10;    if (! -r $privKeyFile) {&#10;        die "ssh_connect: Private key file '$privKeyFile' does not exist " .&#10;            "or is not readable\n";&#10;    }&#10;&#10;    # Ok, try and connect...&#10;&#10;    my $ssh2 = Net::SSH2-&gt;new();&#10;    my $result = eval {&#10;        $ssh2-&gt;connect($host, $port);&#10;    };&#10;&#10;    if (!$result) {&#10;        die "ssh_connect: Error connecting to $host:$port: $!\n";&#10;    }&#10;&#10;    if ($self-&gt;getDbg &gt; 4) {&#10;        $ssh2-&gt;debug(1);&#10;    }&#10;    $self-&gt;debugMsg(5,"ssh_connect: Creating session : Connecting to " .&#10;         "$host:$port with userName=$userName pubKeyFile=$pubKeyFile " .&#10;         "privKeyFile=$privKeyFile");&#10;&#10;    # libssh2 has a bug where sometimes key-authentication fails even&#10;    # though the keyfiles are perfectly valid.  Retry upto three more times&#10;    # with a little sleep in between before giving up.&#10;&#10;    my $attemptCount = 1;&#10;    my $maxAttempts = 4;&#10;    my $errorString;&#10;    for (; $attemptCount &lt;= $maxAttempts &amp;&amp; &#10;         !$ssh2-&gt;auth_publickey($userName, $pubKeyFile, $privKeyFile);&#10;         $attemptCount++) {&#10;        $errorString = ($ssh2-&gt;error())[2];&#10;        $self-&gt;debugMsg(5,"Authentication attempt $attemptCount failed with error: " .&#10;             "$errorString");&#10;        sleep 2;&#10;    }&#10;    &#10;    if ($attemptCount == $maxAttempts+1) {&#10;        my $msg =&#10;            "ssh_connect: Key authentication failed for $userName using " .&#10;            "the following key files:\n" .&#10;            "public key file: $pubKeyFile\n" .&#10;            "private key file: $privKeyFile\n" .&#10;            "error detail: $errorString";&#10;        &#10;        $self-&gt;errorMsg(4,$msg);&#10;    }&#10;&#10;    # Success! Save off the session handle.&#10;    my $context =  $ssh2;&#10;    $self-&gt;debugMsg(5,"ssh_connect: Connection succeeded!");&#10;&#10;    return $context;&#10;}&#10;&#10;# ------------------------------------------------------------------------&#10;# ssh_runCommand&#10;#&#10;#      Runs the given command-line on the proxy target and streams the&#10;#      result to stdout.&#10;#&#10;# Arguments:&#10;#      context       - Context object that contains connection info.&#10;#      cmdLine       - command-line to execute.&#10;# ------------------------------------------------------------------------&#10;&#10;sub ssh_runCommand {&#10;    my ($self,$context, $cmdLine,$input) = @_;&#10;&#10;    my $channel = $context-&gt;channel();&#10;    $channel-&gt;blocking(0);&#10;    $channel-&gt;ext_data('merge');&#10;    $channel-&gt;exec($cmdLine);&#10;    $channel-&gt;write($input);&#10;&#10;    my $out = "";&#10;    my $buf;&#10;    while (!$channel-&gt;eof()) {&#10;        if (defined($channel-&gt;read($buf, 4096))) {&#10;            $out .= $buf;&#10;        } else {&#10;            # We got no data; try again in a second.&#10;            sleep 1;&#10;        }&#10;    }&#10;    return ($channel-&gt;exit_status(),$out);&#10;}&#10;&#10;####################################################################&#10;# dumpOpts&#10;#&#10;####################################################################&#10;sub dumpOpts{&#10;   my ($self, $opts) = @_;&#10;   print "\n-------------start opts------------\n";&#10;   foreach my $e (keys % {$opts}) {&#10;       print "  key=$e, val=$opts-&gt;{$e}\n";&#10;   }&#10;   print "\n-------------end opts------------\n";&#10;}&#10;&#10;1;&#10;</value>
					</property>
				</propertySheet>
			</property>
			<property>
				<propertyName>ui_forms</propertyName>
				<description>Property sheet to hold xml specification for forms</description>
				<propertySheet>
					<property>
						<propertyName>GerritCreateConfigForm</propertyName>
						<expandable>1</expandable>
						<value></value>
					</property>
					<property>
						<propertyName>GerritEditConfigForm</propertyName>
						<description/>
						<expandable>1</expandable>
						<value></value>
					</property>
				</propertySheet>
			</property>
			<property>
				<propertyName>ec_setup</propertyName>
				<expandable>0</expandable>
				<value></value>
			</property>
			<property>
				<propertyName>ec_visibility</propertyName>
				<description/>
				<expandable>1</expandable>
				<value>pickListOnly</value>
			</property>
		</propertySheet>
		<procedure>
			<procedureName>CreateConfiguration</procedureName>
			<description>Create a Gerrit configuration.</description>
			<jobNameTemplate>gerrit-cfg-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>ResourcePool</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>cmdr_webserver</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>config</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>debug</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>desc</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>devbuild_cmdr_procedure</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>devbuild_cmdr_project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>devbuild_mode</propertyName>
									<propertySheet>
										<property>
											<propertyName>options</propertyName>
											<propertySheet>
												<property>
													<propertyName>option1</propertyName>
													<propertySheet>
														<property>
															<propertyName>text</propertyName>
															<expandable>1</expandable>
															<value>Auto</value>
														</property>
														<property>
															<propertyName>value</propertyName>
															<expandable>1</expandable>
															<value>auto</value>
														</property>
													</propertySheet>
												</property>
												<property>
													<propertyName>option2</propertyName>
													<propertySheet>
														<property>
															<propertyName>text</propertyName>
															<expandable>1</expandable>
															<value>Manual</value>
														</property>
														<property>
															<propertyName>value</propertyName>
															<expandable>1</expandable>
															<value>manual</value>
														</property>
													</propertySheet>
												</property>
												<property>
													<propertyName>optionCount</propertyName>
													<expandable>1</expandable>
													<value>2</value>
												</property>
												<property>
													<propertyName>type</propertyName>
													<expandable>1</expandable>
													<value>list</value>
												</property>
											</propertySheet>
										</property>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_branch</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_manifest</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_port</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_private_key</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_public_key</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_server</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>repository_server</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_user</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>team_build_rules</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>teambuild_project_branches</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>cmdr_webserver</formalParameterName>
				<defaultValue>localhost</defaultValue>
				<description>The ElectricCommander web server</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>config</formalParameterName>
				<defaultValue/>
				<description>The configuration name</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>debug</formalParameterName>
				<defaultValue>1</defaultValue>
				<description>debug level</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>desc</formalParameterName>
				<defaultValue/>
				<description>Description</description>
				<required>0</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>dev_build_rules</formalParameterName>
				<defaultValue/>
				<description>Filter rules for developer build</description>
				<required>1</required>
				<type>textarea</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>devbuild_cmdr_procedure</formalParameterName>
				<defaultValue>DevBuildExample</defaultValue>
				<description>The ElectricCommander procedure to call when a devleoper changeset needs to be built</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>devbuild_cmdr_project</formalParameterName>
				<defaultValue>EC-Gerrit-1.1.1.0</defaultValue>
				<description>The ElectricCommander project that contains the procedure to use when building individual changesets</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>devbuild_mode</formalParameterName>
				<defaultValue>manual</defaultValue>
				<description>Auto: Run the ElectricCommander procedure automatically for each changeset submitted&#10;Manual: Run the ElectricCommander procedure only when the link in Gerrit is clicked</description>
				<required>1</required>
				<type>select</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_branch</formalParameterName>
				<defaultValue>master</defaultValue>
				<description>The branch to watch</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_manifest</formalParameterName>
				<defaultValue>default.xml</defaultValue>
				<description>The manifest file to use for getting files</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_port</formalParameterName>
				<defaultValue/>
				<description>The Gerrit server port</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_private_key</formalParameterName>
				<defaultValue/>
				<description>Path to private key</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_public_key</formalParameterName>
				<defaultValue/>
				<description>Path to public key</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_server</formalParameterName>
				<defaultValue></defaultValue>
				<description>The Gerrit server address</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>repository_server</formalParameterName>
				<defaultValue></defaultValue>
				<description>The server where the repository is located. If not provided, the "Gerrit Server" is used. i.e: in this url "git://github.com/ecGerrit/ecGerritTest.git", the repository server is "github.com".</description>
				<required>0</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>repository_path</formalParameterName>
				<defaultValue></defaultValue>
				<description>The path associated to the "Repository Server". i.e: in this url "git://github.com/ecGerrit/ecGerritTest.git", the repository path is "ecGerrit/ecGerritTest.git". (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_user</formalParameterName>
				<defaultValue/>
				<description>The Gerrit server login user</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>ResourcePool</formalParameterName>
				<defaultValue/>
				<description>The resource pool for Gerrit builds. The resources should have a property named "gerrit_working_dir" which is the location for the cached repo for that workspace.</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>team_build_rules</formalParameterName>
				<defaultValue/>
				<description>Filter rules for team build</description>
				<required>1</required>
				<type>textarea</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>teambuild_project_branches</formalParameterName>
				<defaultValue/>
				<description>The file that contains the name of the projects and branches to be included in the verification. In addition you can specify in here individual changes to be verified. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>CreateConfiguration</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Create a Gerrit configuration</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor>postp</postProcessor>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>local</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit>5</timeLimit>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CreateConfiguration</procedureName>
                <projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>CustomBuildExample</procedureName>
			<description>A sample Custom Build using the helper methods.</description>
			<jobNameTemplate>gerrit-customBuildExample-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>GetCodeFromGerrit</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<condition/>
				<description/>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<parallel>0</parallel>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<subprocedure>CustomBuildPrepare</subprocedure>
				<subproject>/plugins/EC-Gerrit/project</subproject>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<actualParameters>
					<property>
						<propertyName>gerrit_cfg</propertyName>
						<expandable>1</expandable>
						<value>$[gerrit_cfg]</value>
					</property>
				</actualParameters>
				<procedureName>CustomBuildExample</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>procedure</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>DoWork</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>print "Build and test\n";exit 0;</command>
				<condition/>
				<description/>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CustomBuildExample</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>GerritCleanup</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<condition/>
				<description/>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<parallel>0</parallel>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<subprocedure>TeamBuildCleanup</subprocedure>
				<subproject>/plugins/EC-Gerrit/project</subproject>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<actualParameters>
					<property>
						<propertyName>gerrit_cfg</propertyName>
						<expandable>1</expandable>
						<value>$[gerrit_cfg]</value>
					</property>
					<property>
						<propertyName>group_build_changes</propertyName>
						<expandable>1</expandable>
						<value></value>
					</property>
					<property>
						<propertyName>project</propertyName>
						<expandable>1</expandable>
						<value></value>
					</property>
				</actualParameters>
				<procedureName>CustomBuildExample</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>procedure</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>CustomBuildPrepare</procedureName>
			<description>The CustomBuildPrepare use the new helper methods to prepare a custom build.</description>
			<jobNameTemplate>gerrit-customBuildPrepare-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description/>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>allocate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# allocate.pl&#10;##########################&#10;use ElectricCommander;&#10;use File::Basename;&#10;use ElectricCommander::PropDB;&#10;use ElectricCommander::PropMod;&#10;&#10;$|=1;&#10;&#10;my $ec = new ElectricCommander();&#10;$ec-&gt;abortOnError(0);&#10;&#10;my $cfgName = "$[gerrit_cfg]";&#10;my $proj = "$[/myProject/projectName]";&#10;my $cfg = new ElectricCommander::PropDB($ec,"/projects/$proj/gerrit_cfgs");&#10;my %vals = $cfg-&gt;getRow($cfgName);&#10;my $opts = \%vals;&#10;&#10;if ("$opts-&gt;{ResourcePool}" eq "") {&#10;    print "Error: no resource pool specified.\n";&#10;    exit 1;&#10;}&#10;&#10;$ec-&gt;setProperty("/myJob/git_resource",$opts-&gt;{ResourcePool});&#10;exit 0;&#10;</command>
				<condition/>
				<description>Pick a resource for this run</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CustomBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>changes</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# changes.pl&#10;##########################&#10;$[/plugins/EC-Gerrit-1.1.1.0/project/procedure_helpers/api]&#10;&#10;gr_scanChanges($prop, $opts-&gt;{team_build_rules});</command>
				<condition/>
				<description>Get the list of changes to be processed and save for rest of procedure.</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CustomBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>clone</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# clone.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;my $map = $gt-&gt;makeReplacementMap();&#10;&#10;# get values from configuration&#10;# run through replacement twice to allow double indirection&#10;#     i.e.   a-&gt;b-&gt;c&#10;my $cloneCmd  = $gt-&gt;replace_strings("$opts-&gt;{cmd_clone}",$map);&#10;my $cloneCmd  = $gt-&gt;replace_strings("$cloneCmd",$map);&#10;my $updateCmd = $gt-&gt;replace_strings("$opts-&gt;{cmd_update}",$map);&#10;my $updateCmd = $gt-&gt;replace_strings("$updateCmd",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$opts-&gt;{cmd_magic_dir}",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$magicDir",$map);&#10;&#10;&#10;### If working directory is blank&#10;if ("$opts-&gt;{gerrit_working_dir}" eq "") {&#10;    print "Working directory not specified.  Set the directory in a property"&#10;        . " named gerrit_working_dir on the resource.\n";&#10;    exit 1;&#10;}&#10;&#10;### Examine working directory and see if it needs to be created from scratch&#10;if (! -d $opts-&gt;{gerrit_working_dir}) {&#10;    print "Creating a clone of remote repository\n";&#10;    eval "$cloneCmd";&#10;}&#10;&#10;### Do we have an initialized dir?&#10;if (!-d "$opts-&gt;{gerrit_working_dir}/$magicDir") {&#10;    print "$opts-&gt;{gerrit_working_dir} missing directory $magicDir.\n";&#10;    exit 1;&#10;}&#10;&#10;### Sync to head&#10;print "Updating the repository to latest head.\n";&#10;eval  "$updateCmd" ;&#10;&#10;&#10;&#10;&#10;</command>
				<condition>$[/javascript myJob.gerrit_changes]</condition>
				<description/>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CustomBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>revert</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# revert.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;my $map = $gt-&gt;makeReplacementMap();&#10;&#10;my $magicDir  = $gt-&gt;replace_strings("$opts-&gt;{cmd_magic_dir}",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$magicDir",$map);&#10;&#10;my $revertCmd = $gt-&gt;replace_strings("$opts-&gt;{cmd_revert}",$map);&#10;my $revertCmd = $gt-&gt;replace_strings("$revertCmd",$map);&#10;&#10;if (!-d "$opts-&gt;{gerrit_working_dir}/$magicDir") {&#10;    print "$opts-&gt;{gerrit_working_dir} not a git repostitory.\n";&#10;    exit 1;&#10;}&#10;&#10;chdir $opts-&gt;{gerrit_working_dir};&#10;&#10;print "Revert repository to latest head.\n";&#10;eval "$revertCmd" ;&#10;&#10;</command>
				<condition>$[/javascript myJob.gerrit_changes]</condition>
				<description>Get tree in clean state before overlaying files</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CustomBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>apply</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# apply.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;my $map = $gt-&gt;makeReplacementMap();&#10;&#10;# get values from configuration&#10;# run through replacement twice to allow double indirection&#10;#     i.e.   a-&gt;b-&gt;c&#10;&#10;my $magicDir  = $gt-&gt;replace_strings("$opts-&gt;{cmd_magic_dir}",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$magicDir",$map);&#10;&#10;if (!-d "$opts-&gt;{gerrit_working_dir}/$magicDir") {&#10;    print "$opts-&gt;{gerrit_working_dir} missing directory $magicDir.\n";&#10;    exit 1;&#10;}&#10;&#10;my $rawOverlayCmd = "$opts-&gt;{cmd_overlay}";&#10;&#10;chdir $opts-&gt;{gerrit_working_dir};&#10;&#10;my @changes = $gt-&gt;getChanges();&#10;&#10;foreach my $str (@changes) {&#10;    my ($changeid, $patchid,$project) = split (/:/,$str);&#10;    $opts-&gt;{changeid} = $changeid;&#10;    $opts-&gt;{patchid} = $patchid;&#10;    $opts-&gt;{gerrit_project} = $project;&#10;    my $newmap = $gt-&gt;makeReplacementMap();&#10;    my $overlayCmd = $gt-&gt;replace_strings("$rawOverlayCmd",$newmap);&#10;    my $overlayCmd = $gt-&gt;replace_strings("$overlayCmd",$newmap);&#10;    print "overlay cmd\n$overlayCmd\n";&#10;&#10;    print "Get updates\n";&#10;    # create pull command&#10;    eval "$overlayCmd";&#10;}&#10;&#10;&#10;&#10;&#10;&#10;</command>
				<condition>$[/javascript myJob.gerrit_changes]ec</condition>
				<description>Get the changes from Gerrit and overlay on top of  local repository</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>CustomBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>DeleteConfiguration</procedureName>
			<description>Delete a Gerrit configuration</description>
			<jobNameTemplate>gerrit-cfg-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>config</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>config</formalParameterName>
				<defaultValue/>
				<description>The configuration name</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>DeleteConfiguration</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Delete a Gerrit configuration</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor>postp</postProcessor>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>local</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit>5</timeLimit>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DeleteConfiguration</procedureName>
                <projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>DevBuildExample</procedureName>
			<description>An example of a developer build procedure.</description>
			<jobNameTemplate>gerrit-devBuildExample-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>changeid</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>patchid</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>changeid</formalParameterName>
				<defaultValue/>
				<description>The change id to be built. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>patchid</formalParameterName>
				<defaultValue/>
				<description>The patch set id to be built. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>project</formalParameterName>
				<defaultValue/>
				<description>The project that contains the change to build. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>GetCodeFromGerrit</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<condition/>
				<description>Run a test of Gerrit changes</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>0</exclusive>
				<parallel>0</parallel>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<subprocedure>DevBuildPrepare</subprocedure>
				<subproject>/plugins/EC-Gerrit/project</subproject>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<actualParameters>
					<property>
						<propertyName>changeid</propertyName>
						<expandable>1</expandable>
						<value>$[changeid]</value>
					</property>
					<property>
						<propertyName>gerrit_cfg</propertyName>
						<expandable>1</expandable>
						<value>$[gerrit_cfg]</value>
					</property>
					<property>
						<propertyName>patchid</propertyName>
						<expandable>1</expandable>
						<value>$[patchid]</value>
					</property>
					<property>
						<propertyName>project</propertyName>
						<expandable>1</expandable>
						<value>$[project]</value>
					</property>
				</actualParameters>
				<procedureName>DevBuildExample</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>procedure</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>DoWork</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>print "Build and test\n";exit 0;</command>
				<condition/>
				<description>Do the build and test procedures</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildExample</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>GerritCleanup</stepName>
				<alwaysRun>1</alwaysRun>
				<broadcast>0</broadcast>
				<condition/>
				<description>Cleanup the Gerrit environment</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>0</exclusive>
				<parallel>0</parallel>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<subprocedure>DevBuildCleanup</subprocedure>
				<subproject>/plugins/EC-Gerrit/project</subproject>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<actualParameters>
					<property>
						<propertyName>changeid</propertyName>
						<expandable>1</expandable>
						<value>$[changeid]</value>
					</property>
					<property>
						<propertyName>gerrit_cfg</propertyName>
						<expandable>1</expandable>
						<value>$[gerrit_cfg]</value>
					</property>
					<property>
						<propertyName>patchid</propertyName>
						<expandable>1</expandable>
						<value>$[patchid]</value>
					</property>
					<property>
						<propertyName>project</propertyName>
						<expandable>1</expandable>
						<value>$[project]</value>
					</property>
				</actualParameters>
				<procedureName>DevBuildExample</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>procedure</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>DevBuildCleanup</procedureName>
			<description>Cleanup after one developer build. The working tree is cleaned up (runtime artifacts removed, change backed out).  This also marks the job as complete in Gerrit comments.</description>
			<jobNameTemplate>gerrit-devBuildCleanup-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
					<propertyName>ec_parameterForm</propertyName>    
					<expandable>1</expandable>
					<value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>changeid</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>patchid</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>changeid</formalParameterName>
				<defaultValue/>
				<description>The short change id to be built. i.e: '5'. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>patchid</formalParameterName>
				<defaultValue/>
				<description>The short patch set id to be built. i.e: '5'. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>project</formalParameterName>
				<defaultValue/>
				<description>The project that contains the change to build. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>annotate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Annotate Gerrit to tell it the job has finished</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName></resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildCleanup</procedureName>
				<projectName>Gerrit</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>DevBuildPrepare</procedureName>
			<description>Prepare for a developer build. This will be one change. The working tree will be adjusted to be the head of the branch plus changes in the change</description>
			<jobNameTemplate>gerrit-devBuildPrepare-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
					<propertyName>ec_parameterForm</propertyName>    
					<expandable>1</expandable>
					<value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>changeid</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>patchid</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>changeid</formalParameterName>
				<defaultValue/>
				<description>The change id to be built. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>patchid</formalParameterName>
				<defaultValue/>
				<description>The patch set id to be built. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>project</formalParameterName>
				<defaultValue/>
				<description>The project that contains the change to build. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>allocate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Pick a resource for this run</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>annotate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>If this job was launched manually, annotate Gerrit so it knows about the job</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>clone</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>If needed, clone the remote repo in gerrit to a working directory then fetch contents. The tree should now be in sync with the head of the master.</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>revert</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Get tree in clean state before overlaying files</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>apply</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Get the changes from Gerrit and overlay on top of  local repostiory</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DevBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>DeveloperScan</procedureName>
			<description>Scan the Gerrit server for any new changes and process them</description>
			<jobNameTemplate>gerrit-developerScan-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
      </propertySheet>
			<step>
				<stepName>scan</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Scan the Gerrit server</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor>postp</postProcessor>
				<releaseExclusive>0</releaseExclusive>
				<resourceName></resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit>12</timeLimit>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>DeveloperScan</procedureName>
				<projectName>EC-Gerrit-1.1.1.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>SetupGerritServer</procedureName>
			<description>Setup the default settings into Gerrit to be used with the Electric Commander</description>
			<jobNameTemplate>gerrit-setupGerritServer-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>Setup</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description/>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>SetupGerritServer</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>TeamBuildCleanup</procedureName>
			<description>Mark the changes as approved if success</description>
			<jobNameTemplate>gerrit-teamBuildCleanup-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>group_build_changes</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>group_build_changes</formalParameterName>
				<defaultValue/>
				<description>List of the changes in the group. Any number of lines can be added. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>project</formalParameterName>
				<defaultValue/>
				<description>The project that contains the change to build. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>allocate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Pick a resource for this run</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildCleanup</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>approve</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition></condition>
				<description>Get the changes from Gerrit and overlay on top of  local repostiory</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildCleanup</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>TeamBuildExample</procedureName>
			<description>A sample Team Build procedure.</description>
			<jobNameTemplate>gerrit-teamBuildExample-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>group_build_changes</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>group_build_changes</formalParameterName>
				<defaultValue/>
				<description>List of the changes in the group. Any number of lines can be added. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>project</formalParameterName>
				<defaultValue/>
				<description>The project that contains the change to build. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>GetCodeFromGerrit</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<condition/>
				<description>Run a test of Gerrit changes</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<parallel>0</parallel>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<subprocedure>TeamBuildPrepare</subprocedure>
				<subproject>/plugins/EC-Gerrit/project</subproject>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<actualParameters>
					<property>
						<propertyName>gerrit_cfg</propertyName>
						<expandable>1</expandable>
						<value>$[gerrit_cfg]</value>
					</property>
					<property>
						<propertyName>group_build_changes</propertyName>
						<expandable>1</expandable>
						<value>$[group_build_changes]</value>
					</property>
					<property>
						<propertyName>project</propertyName>
						<expandable>1</expandable>
						<value>$[project]</value>
					</property>
				</actualParameters>
				<procedureName>TeamBuildExample</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>procedure</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>DoWork</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>print "Build and test\n";exit 0;</command>
				<condition/>
				<description>Do the build and test procedures</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildExample</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>GerritCleanup</stepName>
				<alwaysRun>1</alwaysRun>
				<broadcast>0</broadcast>
				<condition/>
				<description>Cleanup the Gerrit environment</description>
				<errorHandling>failProcedure</errorHandling>
				<exclusive>0</exclusive>
				<parallel>0</parallel>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<subprocedure>TeamBuildCleanup</subprocedure>
				<subproject>/plugins/EC-Gerrit/project</subproject>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<actualParameters>
					<property>
						<propertyName>gerrit_cfg</propertyName>
						<expandable>1</expandable>
						<value>$[gerrit_cfg]</value>
					</property>
					<property>
						<propertyName>group_build_changes</propertyName>
						<expandable>1</expandable>
						<value>$[group_build_changes]</value>
					</property>
					<property>
						<propertyName>project</propertyName>
						<expandable>1</expandable>
						<value>$[project]</value>
					</property>
				</actualParameters>
				<procedureName>TeamBuildExample</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>procedure</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<procedure>
			<procedureName>TeamBuildPrepare</procedureName>
			<description>Create a tree in /myResource/gerrit_working_dir with the head of the branch and an overlay of all open Gerrit changes which match the configuration filters</description>			
			<jobNameTemplate>gerrit-teamBuildPrepare-$[/increment /myJob/project/jobCounter]</jobNameTemplate>
			<projectName>@PLUGIN_KEY@-@PLUGIN_VERSION@</projectName>
			<propertySheet>
                <property>
                        <propertyName>ec_parameterForm</propertyName>    
                        <expandable>1</expandable>
                        <value></value>
                </property>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>parameters</propertyName>
							<propertySheet>
								<property>
									<propertyName>gerrit_cfg</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>group_build_changes</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
								<property>
									<propertyName>project</propertyName>
									<propertySheet>
										<property>
											<propertyName>formType</propertyName>
											<expandable>1</expandable>
											<value>standard</value>
										</property>
									</propertySheet>
								</property>
							</propertySheet>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
			<formalParameter>
				<formalParameterName>gerrit_cfg</formalParameterName>
				<defaultValue>default</defaultValue>
				<description>The name of the config which holds all the connection information for Gerrit. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>group_build_changes</formalParameterName>
				<defaultValue/>
				<description>List of the changes in the group. (Required)</description>
				<required>1</required>
				<type>textarea</type>
			</formalParameter>
			<formalParameter>
				<formalParameterName>project</formalParameterName>
				<defaultValue/>
				<description>The project that contains the change to build. (Required)</description>
				<required>1</required>
				<type>entry</type>
			</formalParameter>
			<step>
				<stepName>allocate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command></command>
				<condition/>
				<description>Pick a resource for this run</description>
				<errorHandling>abortProcedure</errorHandling>
				<exclusive>0</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName/>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>changes</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# changes.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;# get all eligible change/patch combinations from Gerrit&#10;#my @changes = $gt-&gt;team_build("$[project]", $opts-&gt;{gerrit_branch},$opts-&gt;{team_build_rules},$opts-&gt;{teambuild_project_branches});&#10;my @changes = $gt-&gt;team_build($opts-&gt;{team_build_rules},$opts-&gt;{teambuild_project_branches});&#10;&#10;if (scalar @changes == 0) {&#10;    print "No changes meet the filter criteria.\n";&#10;    exit 0;&#10;}&#10;&#10;# save changes so that code extraction, build, and comments&#10;# all operate on this list regardeless of other changes&#10;# that appear in mid flight&#10;my $json = JSON-&gt;new-&gt;utf8;&#10;my $change_str = $json-&gt;encode(\@changes);&#10;&#10;print "===CHANGES===\n";&#10;print $change_str . "\n";&#10;&#10;$gt-&gt;getCmdr()-&gt;setProperty("/myJob/gerrit_changes", $change_str);&#10;&#10;&#10;</command>
				<condition/>
				<description>Get the list of changes to be processed and save for rest of procedure.</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>annotate</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command/>
				<condition/>
				<description>Get the list of changes to be processed and save for rest of procedure.</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>clone</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# clone.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;my $map = $gt-&gt;makeReplacementMap();&#10;&#10;# get values from configuration&#10;# run through replacement twice to allow double indirection&#10;#     i.e.   a-&gt;b-&gt;c&#10;my $cloneCmd  = $gt-&gt;replace_strings("$opts-&gt;{cmd_clone}",$map);&#10;my $cloneCmd  = $gt-&gt;replace_strings("$cloneCmd",$map);&#10;my $updateCmd = $gt-&gt;replace_strings("$opts-&gt;{cmd_update}",$map);&#10;my $updateCmd = $gt-&gt;replace_strings("$updateCmd",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$opts-&gt;{cmd_magic_dir}",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$magicDir",$map);&#10;&#10;&#10;### If working directory is blank&#10;if ("$opts-&gt;{gerrit_working_dir}" eq "") {&#10;    print "Working directory not specified.  Set the directory in a property"&#10;        . " named gerrit_working_dir on the resource.\n";&#10;    exit 1;&#10;}&#10;&#10;### Examine working directory and see if it needs to be created from scratch&#10;if (! -d $opts-&gt;{gerrit_working_dir}) {&#10;    print "Creating a clone of remote repository\n";&#10;    eval "$cloneCmd";&#10;}&#10;&#10;### Do we have an initialized dir?&#10;if (!-d "$opts-&gt;{gerrit_working_dir}/$magicDir") {&#10;    print "$opts-&gt;{gerrit_working_dir} missing directory $magicDir.\n";&#10;    exit 1;&#10;}&#10;&#10;### Sync to head&#10;print "Updating the repository to latest head.\n";&#10;eval  "$updateCmd" ;&#10;&#10;&#10;&#10;&#10;</command>
				<condition>$[/javascript myJob.gerrit_changes]</condition>
				<description>If needed, clone the remote repo in gerrit to a working directory then fetch contents. The tree should now be in sync with the head of the master.</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>revert</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# revert.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;my $map = $gt-&gt;makeReplacementMap();&#10;&#10;my $magicDir  = $gt-&gt;replace_strings("$opts-&gt;{cmd_magic_dir}",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$magicDir",$map);&#10;&#10;my $revertCmd = $gt-&gt;replace_strings("$opts-&gt;{cmd_revert}",$map);&#10;my $revertCmd = $gt-&gt;replace_strings("$revertCmd",$map);&#10;&#10;if (!-d "$opts-&gt;{gerrit_working_dir}/$magicDir") {&#10;    print "$opts-&gt;{gerrit_working_dir} not a git repostitory.\n";&#10;    exit 1;&#10;}&#10;&#10;chdir $opts-&gt;{gerrit_working_dir};&#10;&#10;print "Revert repository to latest head.\n";&#10;eval "$revertCmd" ;&#10;&#10;</command>
				<condition>$[/javascript myJob.gerrit_changes]</condition>
				<description>Get tree in clean state before overlaying files</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
			<step>
				<stepName>apply</stepName>
				<alwaysRun>0</alwaysRun>
				<broadcast>0</broadcast>
				<command>##########################&#10;# apply.pl&#10;##########################&#10;$[/myProject/procedure_helpers/preamble]&#10;&#10;my $map = $gt-&gt;makeReplacementMap();&#10;&#10;# get values from configuration&#10;# run through replacement twice to allow double indirection&#10;#     i.e.   a-&gt;b-&gt;c&#10;&#10;my $magicDir  = $gt-&gt;replace_strings("$opts-&gt;{cmd_magic_dir}",$map);&#10;my $magicDir  = $gt-&gt;replace_strings("$magicDir",$map);&#10;&#10;if (!-d "$opts-&gt;{gerrit_working_dir}/$magicDir") {&#10;    print "$opts-&gt;{gerrit_working_dir} missing directory $magicDir.\n";&#10;    exit 1;&#10;}&#10;&#10;my $rawOverlayCmd = "$opts-&gt;{cmd_overlay}";&#10;&#10;chdir $opts-&gt;{gerrit_working_dir};&#10;&#10;my @changes = $gt-&gt;getChanges();&#10;&#10;foreach my $str (@changes) {&#10;    my ($changeid, $patchid,$project) = split (/:/,$str);&#10;    $opts-&gt;{changeid} = $changeid;&#10;    $opts-&gt;{patchid} = $patchid;&#10;    $opts-&gt;{gerrit_project} = $project;&#10;    my $newmap = $gt-&gt;makeReplacementMap();&#10;    my $overlayCmd = $gt-&gt;replace_strings("$rawOverlayCmd",$newmap);&#10;    my $overlayCmd = $gt-&gt;replace_strings("$overlayCmd",$newmap);&#10;    print "overlay cmd\n$overlayCmd\n";&#10;&#10;    print "Get updates\n";&#10;    # create pull command&#10;    eval "$overlayCmd";&#10;}&#10;&#10;&#10;&#10;&#10;&#10;</command>
				<condition>$[/javascript myJob.gerrit_changes]</condition>
				<description>Get the changes from Gerrit and overlay on top of  local repostiory</description>
				<errorHandling>abortJob</errorHandling>
				<exclusive>1</exclusive>
				<logFileName/>
				<parallel>0</parallel>
				<postProcessor/>
				<releaseExclusive>0</releaseExclusive>
				<resourceName>$[/myJob/git_resource]</resourceName>
				<retries>0</retries>
				<shell>ec-perl</shell>
				<timeLimit/>
				<timeLimitUnits>minutes</timeLimitUnits>
				<workingDirectory/>
				<workspaceName/>
				<procedureName>TeamBuildPrepare</procedureName>
				<projectName>EC-Gerrit-1.2.0.0</projectName>
				<propertySheet>
					<property>
						<propertyName>ec_customEditorData</propertyName>
						<propertySheet>
							<property>
								<propertyName>formType</propertyName>
								<expandable>1</expandable>
								<value>command</value>
							</property>
						</propertySheet>
					</property>
				</propertySheet>
			</step>
		</procedure>
		<schedule>
			<scheduleName>Gerrit New Change Scanner</scheduleName>
			<beginDate/>
			<description>Scan the gerrit server for changes</description>
			<endDate/>
			<interval>15</interval>
			<intervalUnits>minutes</intervalUnits>
			<misfirePolicy>ignore</misfirePolicy>
			<monthDays/>
			<priority>normal</priority>
			<procedureName>DeveloperScan</procedureName>
			<scheduleDisabled>1</scheduleDisabled>
			<startTime/>
			<stopTime/>
			<timeZone>America/Los_Angeles</timeZone>
			<weekDays/>
			<projectName>EC-Gerrit-1.2.0.0</projectName>
			<propertySheet>
				<property>
					<propertyName>ec_customEditorData</propertyName>
					<propertySheet>
						<property>
							<propertyName>formType</propertyName>
							<expandable>1</expandable>
							<value>standard</value>
						</property>
					</propertySheet>
				</property>
			</propertySheet>
		</schedule>
	</project>
</exportedData>
